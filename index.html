<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature-Rich M3U Streamer</title>
    <!-- Tailwind CSS CDN - For production, consider using PostCSS plugin or Tailwind CLI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">    <style>
        body { font-family: 'Inter', sans-serif; }
        #channel-list-container {
            scrollbar-width: thin;
            scrollbar-color: #4a5568 #1a202c;
        }
        #channel-list-container::-webkit-scrollbar { width: 8px; }
        #channel-list-container::-webkit-scrollbar-track { background: #1a202c; }
        #channel-list-container::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 4px; }
        .channel-item.active { background-color: #2b6cb0; box-shadow: 0 0 0 2px #60a5fa; }
        .favorite-star.favorited { color: #f6e05e; /* yellow-400 */ }
        .loader { border-top-color: #3498db; }
        
        /* Enhanced visual feedback */
        .channel-item:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .channel-item { transition: all 0.2s ease; }
        
        /* Fullscreen button styling */
        .control-btn { 
            background: rgba(0,0,0,0.6); 
            backdrop-filter: blur(4px);
            transition: all 0.2s ease;
        }
        .control-btn:hover { background: rgba(0,0,0,0.8); transform: scale(1.05); }
        
        /* Better loading animation */
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .loading-text { animation: pulse 1.5s ease-in-out infinite; }
        
        /* Theme variables */
        :root {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --text-primary: #ffffff;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --border-color: #4b5563;
            --accent-color: #3b82f6;
        }
        
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-tertiary: #f3f4f6;
            --text-primary: #111827;
            --text-secondary: #374151;
            --text-muted: #6b7280;
            --border-color: #d1d5db;
            --accent-color: #3b82f6;
        }
        
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .bg-gray-900 { background-color: var(--bg-primary) !important; }
        .bg-gray-800 { background-color: var(--bg-secondary) !important; }
        .bg-gray-700 { background-color: var(--bg-tertiary) !important; }
        .text-white { color: var(--text-primary) !important; }
        .text-gray-400 { color: var(--text-muted) !important; }
        .border-gray-700 { border-color: var(--border-color) !important; }
        .border-gray-600 { border-color: var(--border-color) !important; }
        
        /* Theme toggle button */
        .theme-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }
        .theme-toggle:hover {
            background: var(--accent-color);
            color: white;
        }

        /* Virtual scrolling container */
        .virtual-container {
            position: relative;
            overflow-y: auto;
            height: 100%;
        }
        
        .virtual-content {
            position: relative;
        }
        
        .virtual-viewport {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
        }

        /* Mobile improvements */
        @media (max-width: 768px) {
            #channel-list { grid-template-columns: 1fr !important; }
            .channel-item { padding: 16px !important; }
        }
        
        /* Status indicators */
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-online { background-color: #10b981; }
        .status-loading { background-color: #f59e0b; animation: pulse 1s infinite; }
        .status-error { background-color: #ef4444; }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col">    <!-- Video Player Section -->
    <div class="w-full bg-black flex-shrink-0 relative group">
        <video id="video-player" class="w-full h-full max-h-[50vh]" controls preload="metadata"></video>
        <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2">
            <button id="fullscreen-btn" title="Fullscreen (F)" class="control-btn text-white p-2 rounded-full hover:bg-opacity-75">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/>
                </svg>
            </button>
            <button id="pip-btn" title="Picture-in-Picture (P)" class="control-btn text-white p-2 rounded-full hover:bg-opacity-75">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M0 3.5A1.5 1.5 0 0 1 1.5 2h13A1.5 1.5 0 0 1 16 3.5v9A1.5 1.5 0 0 1 14.5 14h-13A1.5 1.5 0 0 1 0 12.5v-9zM1.5 3a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-13z"/>
                    <path d="M8 8.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5v-3z"/>
                </svg>
            </button>
        </div>
        <div id="current-channel" class="text-center py-2 text-base font-semibold bg-gray-800 flex items-center justify-center">
            <span id="status-indicator" class="status-indicator mr-2" style="display: none;"></span>
            <span id="channel-name">Select a channel to start playing</span>
        </div>
    </div>    <!-- Controls Section -->
    <div class="flex-shrink-0 p-3 bg-gray-800 border-t border-gray-700 space-y-3">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
            <button id="manage-playlists-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2" viewBox="0 0 16 16">
                    <path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/>
                </svg>
                Manage Playlists
            </button>
            <select id="playlist-select" class="bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            <input id="epg-url" type="text" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter EPG XMLTV URL (optional)">
            <button id="load-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2" viewBox="0 0 16 16">
                    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                    <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
                </svg>
                Load Playlist
            </button>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
            <input id="search-input" type="text" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Search channels... (Ctrl+F)">
            <select id="group-filter" class="bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            <select id="quality-select" class="bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="auto">Auto Quality</option>
                <option value="high">High Quality</option>
                <option value="medium">Medium Quality</option>
                <option value="low">Low Quality</option>
            </select>
        </div>        <div class="text-xs text-gray-400 text-center flex items-center justify-between">
            <span>Shortcuts: Space (Play/Pause) ‚Ä¢ ‚Üë‚Üì (Volume) ‚Ä¢ ‚Üê‚Üí (Seek) ‚Ä¢ F (Fullscreen) ‚Ä¢ P (PiP) ‚Ä¢ T (Theme) ‚Ä¢ Ctrl+F (Search)</span>
            <div class="ml-auto flex gap-2">
                <button id="theme-toggle" class="theme-toggle px-3 py-1 rounded text-xs transition-colors" title="Toggle theme (T)">
                    <svg id="theme-icon" xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
                    </svg>
                </button>
                <button id="debug-toggle" class="bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white px-2 py-1 rounded text-xs transition-colors" title="Show debug info">
                    Debug
                </button>
            </div>
        </div>
    </div>    
    <div id="error-message" class="text-red-400 text-sm p-3 bg-red-900 border-l-4 border-red-500 hidden flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2 flex-shrink-0" viewBox="0 0 16 16">
            <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/>
        </svg>
        <span id="error-text"></span>
        <button id="close-error" class="ml-auto text-red-300 hover:text-red-100">√ó</button>
    </div>

    <!-- Success Message -->
    <div id="success-message" class="text-green-400 text-sm p-3 bg-green-900 border-l-4 border-green-500 hidden flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2 flex-shrink-0" viewBox="0 0 16 16">
            <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
            <path d="M10.97 4.97a.235.235 0 0 0-.02.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.061L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-1.071-1.05z"/>
        </svg>
        <span id="success-text"></span>
        <button id="close-success" class="ml-auto text-green-300 hover:text-green-100">√ó</button>
    </div>    <!-- Channel List -->
    <main id="channel-list-container" class="flex-grow overflow-y-auto p-3 virtual-container">
        <div id="virtual-content" class="virtual-content">
            <div id="channel-list" class="virtual-viewport grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3">
                <p class="text-gray-400 col-span-full text-center">Manage and load a playlist to get started.</p>
            </div>
        </div>
    </main>

    <!-- Debug Panel -->
    <div id="debug-panel" class="fixed bottom-4 right-4 bg-gray-800 border border-gray-600 rounded-lg p-4 max-w-md hidden z-30">
        <div class="flex items-center justify-between mb-3">
            <h3 class="text-white font-semibold">Stream Debug Info</h3>
            <button id="close-debug" class="text-gray-400 hover:text-white">√ó</button>
        </div>
        <div id="debug-content" class="text-sm text-gray-300 space-y-2">
            <div><strong>Stream URL:</strong> <span id="debug-url" class="break-all">-</span></div>
            <div><strong>Method:</strong> <span id="debug-method">-</span></div>
            <div><strong>Status:</strong> <span id="debug-status">-</span></div>
            <div><strong>Quality:</strong> <span id="debug-quality">-</span></div>
            <div><strong>Network:</strong> <span id="debug-network">-</span></div>
            <div><strong>Browser Support:</strong> <span id="debug-support">-</span></div>
            <div><strong>Attempts:</strong> <span id="debug-attempts">-</span></div>
            <div><strong>Last Error:</strong> <span id="debug-error" class="text-red-400">-</span></div>
        </div>
        <div class="mt-3 space-x-2">
            <button id="debug-copy" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-xs">Copy Info</button>
            <button id="debug-test" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-xs">Test Stream</button>
        </div>
    </div><!-- Loading Spinner -->
    <div id="loader-overlay" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center hidden z-50">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24 animate-spin mb-4"></div>
        <div id="loading-title" class="text-white text-lg font-semibold loading-text mb-2">Loading playlist...</div>
        <div id="loading-progress" class="text-blue-400 text-base font-medium mb-2"></div>
        <div id="loading-details" class="text-gray-400 text-sm text-center max-w-md">
            Please wait while we fetch your channels
        </div>
        <div id="loading-stats" class="text-gray-500 text-xs mt-4 text-center"></div>
        
        <!-- Progress Bar -->
        <div class="w-80 bg-gray-700 rounded-full h-2 mt-4 hidden" id="progress-bar-container">
            <div id="progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
    </div>

    <!-- Playlist Management Modal -->    <div id="playlist-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-40">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg space-y-4">
            <h2 class="text-2xl font-bold">Manage Playlists</h2>
            <div id="playlist-manager-list" class="space-y-2 max-h-64 overflow-y-auto"></div>
            
            <!-- Playlist Type Toggle -->
            <div class="space-y-4 border-t border-gray-600 pt-4">
                <div class="flex items-center space-x-4">
                    <label class="text-sm font-medium">Playlist Type:</label>
                    <div class="flex rounded-lg overflow-hidden">
                        <button id="m3u-mode-btn" class="px-4 py-2 bg-blue-600 text-white text-sm font-medium transition-colors">M3U URL</button>
                        <button id="xtreme-mode-btn" class="px-4 py-2 bg-gray-600 text-white text-sm font-medium transition-colors">Xtreme Codes</button>
                    </div>
                </div>
                
                <!-- M3U Mode Fields -->
                <div id="m3u-fields" class="space-y-2">
                    <input type="text" id="new-playlist-name" placeholder="Playlist Name" class="w-full bg-gray-700 rounded p-2">
                    <input type="url" id="new-playlist-url" placeholder="Playlist M3U URL" class="w-full bg-gray-700 rounded p-2">
                </div>
                
                <!-- Xtreme Codes Mode Fields -->
                <div id="xtreme-fields" class="space-y-2 hidden">
                    <input type="text" id="xtreme-playlist-name" placeholder="Playlist Name" class="w-full bg-gray-700 rounded p-2">
                    <input type="url" id="xtreme-portal-url" placeholder="Portal URL (e.g., http://example.com:8080)" class="w-full bg-gray-700 rounded p-2">
                    <input type="text" id="xtreme-username" placeholder="Username" class="w-full bg-gray-700 rounded p-2">
                    <input type="password" id="xtreme-password" placeholder="Password" class="w-full bg-gray-700 rounded p-2">
                    <div class="text-xs text-gray-400 mt-1">
                        Enter your Xtreme Codes panel credentials. The system will automatically generate the M3U URL.
                    </div>
                </div>
                
                <button id="add-playlist-btn" class="w-full bg-green-600 hover:bg-green-700 p-2 rounded">Add Playlist</button>
            </div>
            <button id="close-modal-btn" class="mt-4 w-full bg-gray-600 hover:bg-gray-700 p-2 rounded">Close</button>        </div>
    </div>
    
    <script>    document.addEventListener('DOMContentLoaded', () => {        // --- SECURITY CONTEXT DETECTION ---
        const isHttpsPage = window.location.protocol === 'https:';
        const isDevelopmentLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        
        // Store security context globally for use throughout the app
        window.securityContext = {
            isHttps: isHttpsPage,
            isDevelopment: isDevelopmentLocal,
            mixedContentBlocked: false, // Always false - allow all HTTP streams
            cspEnabled: false,
            allowAllMethods: true, // Force allow all playback methods
            forceHttpAccess: true, // New flag to force HTTP stream access
            bypassAllSecurity: true // Bypass all browser security restrictions
        };
        
        // Check for Content Security Policy
        const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
        if (cspMeta) {
            window.securityContext.cspEnabled = true;
            console.log('üõ°Ô∏è CSP detected - will attempt bypass methods:', cspMeta.content);
        }
        
        // Listen for CSP violations but don't let them stop us
        document.addEventListener('securitypolicyviolation', function(e) {
            console.warn('üö´ CSP Violation detected - will use proxy methods:', {
                blockedURI: e.blockedURI,
                violatedDirective: e.violatedDirective,
                originalPolicy: e.originalPolicy
            });
        });
        
        // Always log permissive approach
        console.log('üåê HTTP Stream Access: Enabled - All streams will be attempted via multiple methods');
        if (window.securityContext.isHttps) {
            console.log('ÔøΩ HTTPS to HTTP Bridge: Active - Using proxy and fallback methods for mixed content');
        }
        
        console.log('üîç Security Context:', window.securityContext);
        
        // --- CONSTANTS ---
        // Enhanced proxy list with development fallbacks
        const PROXIES = [
            // High-reliability public proxies (2025)
            'https://cors.eu.org/',
            'https://thingproxy.freeboard.io/fetch/',
            'https://cors.bridged.cc/',
            'https://api.cors.lol/?url=',
            // Backup public proxies
            'https://api.allorigins.win/raw?url=',
            'https://cors-proxy.fringe.zone/',
            'https://proxy-cors.isomorphic-git.org/',
            // Alternative method proxies
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://yacdn.org/proxy/'
        ];
        
        // --- DOM ELEMENTS ---
        const videoPlayer = document.getElementById('video-player');
        const currentChannelDisplay = document.getElementById('current-channel');
        const channelNameDisplay = document.getElementById('channel-name');
        const statusIndicator = document.getElementById('status-indicator');
        const loadBtn = document.getElementById('load-btn');
        const channelList = document.getElementById('channel-list');
        const searchInput = document.getElementById('search-input');
        const groupFilter = document.getElementById('group-filter');
        const qualitySelect = document.getElementById('quality-select');
        const epgUrlInput = document.getElementById('epg-url');
        const errorMessage = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        const successMessage = document.getElementById('success-message');
        const successText = document.getElementById('success-text');
        const closeErrorBtn = document.getElementById('close-error');
        const closeSuccessBtn = document.getElementById('close-success');
        const loaderOverlay = document.getElementById('loader-overlay');
        const loadingTitle = document.getElementById('loading-title');
        const loadingProgress = document.getElementById('loading-progress');
        const loadingDetails = document.getElementById('loading-details');
        const loadingStats = document.getElementById('loading-stats');
        const progressBarContainer = document.getElementById('progress-bar-container');
        const progressBar = document.getElementById('progress-bar');
        const pipBtn = document.getElementById('pip-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const managePlaylistsBtn = document.getElementById('manage-playlists-btn');
        const playlistModal = document.getElementById('playlist-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const playlistSelect = document.getElementById('playlist-select');
        const playlistManagerList = document.getElementById('playlist-manager-list');
        const addPlaylistBtn = document.getElementById('add-playlist-btn');
        const newPlaylistNameInput = document.getElementById('new-playlist-name');
        const newPlaylistUrlInput = document.getElementById('new-playlist-url');
        
        // Xtreme Codes elements
        const m3uModeBtn = document.getElementById('m3u-mode-btn');
        const xtremeModeBtn = document.getElementById('xtreme-mode-btn');
        const m3uFields = document.getElementById('m3u-fields');
        const xtremeFields = document.getElementById('xtreme-fields');
        const xtremePlaylistNameInput = document.getElementById('xtreme-playlist-name');
        const xtremePortalUrlInput = document.getElementById('xtreme-portal-url');
        const xtremeUsernameInput = document.getElementById('xtreme-username');
        const xtremePasswordInput = document.getElementById('xtreme-password');
        
        // Debug panel elements
        const debugPanel = document.getElementById('debug-panel');
        const debugToggleBtn = document.getElementById('debug-toggle');
        const closeDebugBtn = document.getElementById('close-debug');
        const debugUrl = document.getElementById('debug-url');
        const debugMethod = document.getElementById('debug-method');
        const debugStatus = document.getElementById('debug-status');
        const debugSupport = document.getElementById('debug-support');
        const debugAttempts = document.getElementById('debug-attempts');
        const debugError = document.getElementById('debug-error');
        const debugQuality = document.getElementById('debug-quality');
        const debugNetwork = document.getElementById('debug-network');
        const debugCopyBtn = document.getElementById('debug-copy');
        const debugTestBtn = document.getElementById('debug-test');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const themeIcon = document.getElementById('theme-icon');
        const virtualContent = document.getElementById('virtual-content');
        
        // --- VIRTUAL SCROLLING VARIABLES ---
        let virtualScrollState = {
            itemHeight: 120, // Estimated height per channel item
            containerHeight: 0,
            visibleStart: 0,
            visibleEnd: 0,
            buffer: 10, // Extra items to render outside viewport
            isVirtualized: false,
            allChannels: [],
            visibleChannels: []
        };
        
        // --- THEME MANAGEMENT ---
        function initTheme() {
            // Check for saved theme preference or default to dark
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const theme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
            
            setTheme(theme);
            
            // Listen for system theme changes
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                if (!localStorage.getItem('theme')) {
                    setTheme(e.matches ? 'dark' : 'light');
                }
            });
        }
        
        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            
            // Update icon
            if (theme === 'dark') {
                themeIcon.innerHTML = '<path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>';
            } else {
                themeIcon.innerHTML = '<path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>';
            }
        }
        
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        }
        
        // --- VIRTUAL SCROLLING FUNCTIONS ---
        function initVirtualScrolling() {
            const container = document.getElementById('channel-list-container');
            virtualScrollState.containerHeight = container.clientHeight;
            
            // Calculate how many columns we have
            const computedStyle = window.getComputedStyle(channelList);
            const columns = computedStyle.gridTemplateColumns.split(' ').length;
            virtualScrollState.columns = Math.max(1, columns);
            
            // Add scroll event listener
            container.addEventListener('scroll', throttle(updateVirtualView, 16)); // ~60fps
            
            // Add resize observer to handle window resizing
            const resizeObserver = new ResizeObserver(() => {
                virtualScrollState.containerHeight = container.clientHeight;
                const newColumns = window.getComputedStyle(channelList).gridTemplateColumns.split(' ').length;
                if (newColumns !== virtualScrollState.columns) {
                    virtualScrollState.columns = Math.max(1, newColumns);
                    updateVirtualView();
                }
            });
            resizeObserver.observe(container);
        }
        
        function shouldUseVirtualScrolling(channelCount) {
            return channelCount > 100; // Enable for 100+ channels
        }
        
        function updateVirtualView() {
            if (!virtualScrollState.isVirtualized) return;
            
            const container = document.getElementById('channel-list-container');
            const scrollTop = container.scrollTop;
            const containerHeight = virtualScrollState.containerHeight;
            const itemHeight = virtualScrollState.itemHeight;
            const columns = virtualScrollState.columns;
            const rowHeight = itemHeight + 12; // Include gap
            
            // Calculate visible rows
            const startRow = Math.floor(scrollTop / rowHeight);
            const endRow = Math.min(
                Math.ceil((scrollTop + containerHeight) / rowHeight),
                Math.ceil(virtualScrollState.allChannels.length / columns)
            );
            
            // Add buffer
            const bufferedStart = Math.max(0, startRow - virtualScrollState.buffer);
            const bufferedEnd = Math.min(
                Math.ceil(virtualScrollState.allChannels.length / columns),
                endRow + virtualScrollState.buffer
            );
            
            // Calculate visible channel indices
            const visibleStart = bufferedStart * columns;
            const visibleEnd = Math.min(
                virtualScrollState.allChannels.length,
                bufferedEnd * columns
            );
            
            // Only update if range changed significantly
            if (Math.abs(visibleStart - virtualScrollState.visibleStart) > columns ||
                Math.abs(visibleEnd - virtualScrollState.visibleEnd) > columns) {
                
                virtualScrollState.visibleStart = visibleStart;
                virtualScrollState.visibleEnd = visibleEnd;
                virtualScrollState.visibleChannels = virtualScrollState.allChannels.slice(visibleStart, visibleEnd);
                
                renderVirtualChannels();
            }
        }
        
        function renderVirtualChannels() {
            const totalRows = Math.ceil(virtualScrollState.allChannels.length / virtualScrollState.columns);
            const totalHeight = totalRows * (virtualScrollState.itemHeight + 12);
            const offsetTop = Math.floor(virtualScrollState.visibleStart / virtualScrollState.columns) * (virtualScrollState.itemHeight + 12);
            
            // Set total height for proper scrollbar
            virtualContent.style.height = `${totalHeight}px`;
            
            // Position visible viewport
            channelList.style.transform = `translateY(${offsetTop}px)`;
            
            // Render only visible channels
            displayChannelsVirtual(virtualScrollState.visibleChannels);
        }
        
        function displayChannelsVirtual(channels) {
            channelList.innerHTML = '';
            if (channels.length === 0) return;
            
            channels.forEach(channel => {
                const isFavorite = appState.favorites.includes(channel.id);
                const { now, next } = getEpgForChannel(channel.id);
                const channelCard = document.createElement('div');
                channelCard.className = 'channel-item bg-gray-700 rounded-lg p-3 flex flex-col justify-between cursor-pointer transition hover:bg-gray-600';
                channelCard.style.height = `${virtualScrollState.itemHeight}px`;
                
                // Use lazy loading for logos
                const logoUrl = channel.logo || 'https://placehold.co/40x40/374151/ffffff?text=?';
                
                channelCard.innerHTML = `
                    <div class="flex items-start space-x-3">
                        <img data-src="${logoUrl}" 
                             src="https://placehold.co/40x40/374151/ffffff?text=?" 
                             alt="logo" class="logo-lazy w-10 h-10 rounded-full object-cover bg-gray-600 flex-shrink-0">
                        <span class="font-semibold flex-grow">${channel.name}</span>
                        <span class="favorite-star text-2xl ${isFavorite ? 'favorited' : 'text-gray-500'}" data-channel-id="${channel.id}">&#9733;</span>
                    </div>
                    <div class="text-xs text-gray-300 mt-2 pl-13">
                        <p class="truncate" title="${now || 'No EPG data'}"><strong>Now:</strong> ${now || '...'}</p>
                        <p class="truncate" title="${next || 'No EPG data'}"><strong>Next:</strong> ${next || '...'}</p>
                    </div>`;
                
                channelCard.addEventListener('click', (e) => {
                    if (e.target.classList.contains('favorite-star')) {
                        toggleFavorite(channel.id);
                        e.stopPropagation();
                    } else {
                        const channelIndex = virtualScrollState.allChannels.findIndex(c => c.id === channel.id);
                        currentChannelIndex = channelIndex;
                        playChannel(channel.url, channel.name, channel.id);
                        document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
                        channelCard.classList.add('active');
                    }
                });
                
                channelList.appendChild(channelCard);
            });
            
            // Lazy load visible logos
            lazyLoadLogos();
        }
        
        function lazyLoadLogos() {
            const lazyImages = document.querySelectorAll('.logo-lazy[data-src]');
            const imageObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        const logoUrl = img.dataset.src;
                        
                        // Skip obviously broken URLs to reduce network requests
                        if (!logoUrl || logoUrl === 'null' || logoUrl === 'undefined' || logoUrl.includes('undefined')) {
                            handleLogoError(img, logoUrl);
                            return;
                        }
                        
                        // Check for known problematic domains and skip them
                        const problematicDomains = [
                            'smartxtreamtv.uk',
                            '43topics.com',
                            'cdn.famefocus.com',
                            'img.sharetv.com',
                            'd13ezvd6yrslxm.cloudfront.net',
                            'media.agonybooth.com',
                            'reelydope.com'
                        ];
                        
                        const shouldSkipDirect = problematicDomains.some(domain => logoUrl.includes(domain));
                        
                        const isHttpsLogo = logoUrl.startsWith('https://');
                        const primaryLogo = (isHttpsLogo && !shouldSkipDirect) ? logoUrl : `${PROXIES[0]}${logoUrl}`;
                        const fallbackLogo = isHttpsLogo ? `${PROXIES[0]}${logoUrl}` : `${PROXIES[0]}${encodeURIComponent(logoUrl)}`;
                        
                        img.onerror = function() {
                            this.onerror = null;
                            console.log('üñºÔ∏è Logo failed, trying fallback:', logoUrl.substring(0, 50) + '...');
                            this.src = fallbackLogo;
                            this.onerror = function() {
                                handleLogoError(this, logoUrl);
                            };
                        };
                        img.src = primaryLogo;
                        img.removeAttribute('data-src');
                        img.classList.remove('logo-lazy');
                        imageObserver.unobserve(img);
                    }
                });
            });
            
            lazyImages.forEach(img => imageObserver.observe(img));
        }
        
        function throttle(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // --- NETWORK & QUALITY DETECTION ---
        let networkInfo = {
            connection: null,
            effectiveType: '4g',
            downlink: 10,
            rtt: 50,
            saveData: false,
            isSlowConnection: false
        };
        
        function initNetworkMonitoring() {
            // Get network connection info if available
            if ('connection' in navigator) {
                networkInfo.connection = navigator.connection;
                updateNetworkInfo();
                
                // Listen for network changes
                navigator.connection.addEventListener('change', updateNetworkInfo);
            }
            
            // Fallback: measure network speed periodically
            setInterval(measureNetworkSpeed, 30000); // Every 30 seconds
        }
        
        function updateNetworkInfo() {
            if (networkInfo.connection) {
                networkInfo.effectiveType = networkInfo.connection.effectiveType || '4g';
                networkInfo.downlink = networkInfo.connection.downlink || 10;
                networkInfo.rtt = networkInfo.connection.rtt || 50;
                networkInfo.saveData = networkInfo.connection.saveData || false;
                
                // Determine if connection is slow
                networkInfo.isSlowConnection = 
                    networkInfo.effectiveType === 'slow-2g' ||
                    networkInfo.effectiveType === '2g' ||
                    networkInfo.downlink < 1.5 ||
                    networkInfo.rtt > 300 ||
                    networkInfo.saveData;
                
                console.log('üì° Network updated:', networkInfo);
                autoSelectQuality();
            }
        }
        
        async function measureNetworkSpeed() {
            try {
                const startTime = performance.now();
                const response = await fetch('https://httpbin.org/bytes/100000', { // 100KB test
                    cache: 'no-cache'
                });
                
                if (response.ok) {
                    const endTime = performance.now();
                    const duration = (endTime - startTime) / 1000; // seconds
                    const bitsLoaded = 100000 * 8; // 100KB in bits
                    const speedBps = bitsLoaded / duration;
                    const speedMbps = speedBps / (1024 * 1024);
                    
                    networkInfo.downlink = speedMbps;
                    networkInfo.isSlowConnection = speedMbps < 1.5;
                    
                    console.log(`üìä Network speed: ${speedMbps.toFixed(2)} Mbps`);
                    autoSelectQuality();
                }
            } catch (error) {
                console.warn('Network speed test failed:', error);
            }
        }
        
        function autoSelectQuality() {
            if (appState.currentQuality !== 'auto') return;
            
            let recommendedQuality = 'high';
            
            if (networkInfo.isSlowConnection || networkInfo.effectiveType === '2g' || networkInfo.effectiveType === 'slow-2g') {
                recommendedQuality = 'low';
            } else if (networkInfo.effectiveType === '3g' || networkInfo.downlink < 5) {
                recommendedQuality = 'medium';
            } else if (networkInfo.downlink >= 10) {
                recommendedQuality = 'high';
            }
            
            // Apply quality if it changed
            if (appState.autoSelectedQuality !== recommendedQuality) {
                appState.autoSelectedQuality = recommendedQuality;
                console.log(`üéØ Auto-selected quality: ${recommendedQuality} (${networkInfo.effectiveType}, ${networkInfo.downlink.toFixed(1)}Mbps)`);
                applyQualitySettings();
                
                // Show notification to user
                showError(`Quality auto-adjusted to ${recommendedQuality} based on network conditions`, true);
            }
        }
        
        function applyQualitySettings() {
            if (!videoPlayer.src) return;
            
            const quality = appState.currentQuality === 'auto' ? 
                appState.autoSelectedQuality || 'high' : 
                appState.currentQuality;
            
            // For HLS streams, we can influence quality selection
            if (window.hls && window.hls.levels) {
                switch (quality) {
                    case 'low':
                        // Select lowest quality level
                        const lowestLevel = window.hls.levels.length - 1;
                        window.hls.currentLevel = lowestLevel;
                        break;
                    case 'medium':
                        // Select middle quality level
                        const middleLevel = Math.floor(window.hls.levels.length / 2);
                        window.hls.currentLevel = middleLevel;
                        break;
                    case 'high':
                        // Allow auto quality or select highest
                        window.hls.currentLevel = -1; // auto
                        break;
                }
                console.log(`üì∫ Applied HLS quality: ${quality} (level: ${window.hls.currentLevel})`);
            }
            
            // For regular video, we can adjust some parameters
            if (videoPlayer) {
                switch (quality) {
                    case 'low':
                        videoPlayer.preload = 'metadata';
                        break;
                    case 'medium':
                        videoPlayer.preload = 'auto';
                        break;
                    case 'high':
                        videoPlayer.preload = 'auto';
                        break;
                }
            }
        }
        
        function getQualityInfo() {
            const quality = appState.currentQuality === 'auto' ? 
                appState.autoSelectedQuality || 'high' : 
                appState.currentQuality;
                
            return {
                selected: appState.currentQuality,
                effective: quality,
                networkType: networkInfo.effectiveType,
                speed: `${networkInfo.downlink.toFixed(1)}Mbps`,
                isAutoSelected: appState.currentQuality === 'auto'
            };
        }
        
        function updateDebugInfo() {
            if (debugQuality && debugNetwork) {
                const qualityInfo = getQualityInfo();
                debugQuality.textContent = `${qualityInfo.effective} (${qualityInfo.selected}${qualityInfo.isAutoSelected ? ' - auto' : ''})`;
                debugNetwork.textContent = `${networkInfo.effectiveType} - ${networkInfo.downlink.toFixed(1)}Mbps`;
            }
        }
        
        // Update debug info periodically
        setInterval(updateDebugInfo, 5000);
        
        // --- STATE MANAGEMENT ---
        function loadStateFromStorage() {
            try {
                const saved = localStorage.getItem('iptvPlayerState');
                if (saved) {
                    const savedState = JSON.parse(saved);
                    appState = { ...appState, ...savedState };
                    console.log('üîÑ Loaded state from storage');
                }
            } catch (error) {
                console.error('Error loading state from storage:', error);
            }
        }

        function saveStateToStorage() {
            try {
                // Create a clean copy of appState without large data
                const cleanState = {
                    ...appState,
                    allChannels: [], // Don't store channel data - too large
                    epgData: {} // Don't store EPG data - too large
                };
                
                localStorage.setItem('iptvPlayerState', JSON.stringify(cleanState));
            } catch (error) {
                console.error('Error saving state to storage:', error);
                // If still quota exceeded, clear old data and try again
                if (error.name === 'QuotaExceededError') {
                    console.log('üßπ Clearing localStorage due to quota exceeded');
                    try {
                        localStorage.removeItem('iptvPlayerState');
                        // Save minimal state
                        const minimalState = {
                            playlists: appState.playlists || [],
                            favorites: appState.favorites || [],
                            recents: appState.recents || [],
                            volume: appState.volume || 0.8
                        };
                        localStorage.setItem('iptvPlayerState', JSON.stringify(minimalState));
                    } catch (retryError) {
                        console.error('Failed to save even minimal state:', retryError);
                    }
                }
            }
        }

        // Save state when app state changes
        function updateAppState(updates) {
            appState = { ...appState, ...updates };
            saveStateToStorage();
        }
        
        // Enhanced logo error handling
        function handleLogoError(imgElement, originalUrl) {
            console.log('üñºÔ∏è Logo error for:', originalUrl);
            
            // Create a base64 SVG placeholder that always works
            const placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIiByeD0iMjAiIGZpbGw9IiM0NzQ3NTEiLz4KPHRleHQgeD0iMjAiIHk9IjI1IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTYiIGZpbGw9IndoaXRlIj4/PC90ZXh0Pgo8L3N2Zz4K';
            
            // Remove error handler to prevent infinite loops
            imgElement.onerror = null;
            imgElement.src = placeholder;
            
            // Add a class to indicate this is a fallback
            imgElement.classList.add('logo-fallback');
        }

        let hls = null;
        let currentChannelIndex = -1;
        let displayedChannels = [];
        let retryCount = 0;
        let maxRetries = 2; // Limit retries to prevent infinite loops
        let isPlaybackInProgress = false; // Prevent multiple simultaneous attempts
        let currentChannelName = null; // Track currently playing channel name
        let appState = {
            allChannels: [], epgData: {}, favorites: [], recents: [],
            playlists: [], activePlaylistUrl: '', volume: 0.8, currentQuality: 'auto', autoSelectedQuality: 'high'
        };
        
        // --- IMAGE LOADING HELPER ---
        // Smart image URL generator that avoids double-encoding issues
        function getSmartImageUrls(imageUrl) {
            if (!imageUrl) {
                return {
                    primary: 'https://placehold.co/40x40/374151/ffffff?text=?',
                    fallback: 'https://placehold.co/40x40/374151/ffffff?text=?',
                    placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
                };
            }

            const isHttps = imageUrl.startsWith('https://');
            const isHttp = imageUrl.startsWith('http://');
            
            // For HTTPS images, try direct first (no CORS issues)
            if (isHttps) {
                return {
                    primary: imageUrl,
                    fallback: `${PROXIES[0]}${imageUrl}`, // Try proxied version as fallback
                    placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
                };
            }
            
            // For HTTP images, try proxied first (CORS + mixed content protection)
            if (isHttp) {
                return {
                    primary: `${PROXIES[0]}${imageUrl}`, // Non-encoded proxy
                    fallback: `${PROXIES[1]}${encodeURIComponent(imageUrl)}`, // Try different proxy with encoding
                    placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
                };
            }
            
            // For relative or other URLs, try to make them work
            return {
                primary: `${PROXIES[0]}${imageUrl}`,
                fallback: `${PROXIES[0]}${encodeURIComponent(imageUrl)}`,
                placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
            };
        }

        // --- CORE FUNCTIONS ---
          // Tries to fetch a URL directly first, then using a list of proxies as fallback.
        // url: The original URL to fetch
        // proxyIndex: The current proxy to try from the PROXIES array (-1 means try direct first)
        // Returns: A promise that resolves with the fetch response
        async function fetchWithProxyFallback(url, proxyIndex = -1) {
            // First try direct fetch with enhanced headers for Vercel/cloud environments
            if (proxyIndex === -1) {
                console.log(`Trying direct fetch: ${url}`);
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout for direct
                      const response = await fetch(url, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-store',
                        credentials: 'omit',
                        signal: controller.signal,
                        headers: {
                            'Accept': '*/*'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        console.log('Direct fetch successful');
                        return response;
                    }
                    console.warn(`Direct fetch failed with status: ${response.status}, trying proxies...`);
                } catch (error) {
                    console.warn('Direct fetch failed, trying proxies...', error.name || error.message);
                }
                // If direct fails, start with proxy 0
                return fetchWithProxyFallback(url, 0);
            }

            // Proxy fallback logic with enhanced error handling for Vercel
            if (proxyIndex >= PROXIES.length) {
                throw new Error(`All ${PROXIES.length} proxies failed. This stream may be incompatible with cloud deployment or require special access.

üîß VERCEL-SPECIFIC TROUBLESHOOTING:
‚Ä¢ Some streams are blocked in cloud environments
‚Ä¢ Try using a VPN or different network
‚Ä¢ Check if stream works in VLC player
‚Ä¢ Contact stream provider for web-compatible URLs

Technical details: Network restrictions, CORS policies, or geographic blocking may prevent playback on Vercel's edge network.`);
            }
            
            const proxy = PROXIES[proxyIndex];
            const fetchUrl = proxy + (proxy.includes('?') ? encodeURIComponent(url) : url);
            
            console.log(`Trying to fetch via proxy #${proxyIndex + 1}: ${proxy.replace(/^https?:\/\//, '').split('/')[0]}`);
            
            // Update loading screen with proxy attempt info
            if (loadingDetails && proxyIndex > 0) {
                updateLoadingScreen(
                    loadingTitle.textContent,
                    loadingProgress.textContent,
                    `Trying server ${proxyIndex + 1}/${PROXIES.length}...`,
                    `Previous server failed, retrying with different proxy`,
                    !progressBarContainer.classList.contains('hidden'),
                    progressBar.style.width ? parseInt(progressBar.style.width) : 0
                );
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20s timeout for proxies
                  const response = await fetch(fetchUrl, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-store',
                    credentials: 'omit',
                    signal: controller.signal,
                    headers: {
                        'Accept': '*/*'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    console.warn(`Proxy ${proxy.replace(/^https?:\/\//, '').split('/')[0]} failed with status: ${response.status}`);
                    // Wait before trying next proxy to avoid overwhelming servers
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return fetchWithProxyFallback(url, proxyIndex + 1);
                }
                
                console.log(`Successfully fetched via proxy: ${proxy.replace(/^https?:\/\//, '').split('/')[0]}`);
                return response;
            } catch (error) {
                const errorMsg = error.name === 'AbortError' ? 'timeout' : error.message;
                console.warn(`Proxy ${proxy.replace(/^https?:\/\//, '').split('/')[0]} failed: ${errorMsg}`);
                
                // Add progressive delay between proxy attempts
                const delay = Math.min(500 + (proxyIndex * 200), 2000);
                await new Promise(resolve => setTimeout(resolve, delay));
                
                return fetchWithProxyFallback(url, proxyIndex + 1);
            }
        }
        
        /**
         * Analyzes a stream URL to provide insights about HTTPS compatibility
         * @param {string} url - The stream URL to analyze
         * @returns {object} - Analysis results
         */
        function analyzeStreamCompatibility(url) {
            const analysis = {
                isHttp: url.startsWith('http://'),
                isHttps: url.startsWith('https://'),
                likelyHttpsIncompatible: false,
                reason: '',
                suggestions: []
            };
            
            if (analysis.isHttp) {
                // Check for common IPTV/streaming patterns that are typically HTTP-only
                const httpOnlyPatterns = [
                    /:\d{4,5}\//,  // Non-Standard ports (e.g., :8080/, :1935/)
                    /\/live\//,    // Live streaming endpoints
                    /\/stream\//,  // Stream endpoints
                    /\.ts$/,       // Transport stream files
                    /playlist\.m3u8/, // HLS playlists
                    /chunklist/,   // HLS chunks
                    /udp:\/\//,    // UDP streams
                    /rtmp:\/\//,   // RTMP streams
                ];
                
                analysis.likelyHttpsIncompatible = httpOnlyPatterns.some(pattern => pattern.test(url));
                
                if (analysis.likelyHttpsIncompatible) {
                    analysis.reason = 'URL contains patterns typical of HTTP-only streaming infrastructure';
                    analysis.suggestions = [
                        'Use proxy methods to bypass mixed content restrictions',
                        'Streaming servers often use HTTP due to SSL certificate costs',
                        'Consider asking provider about HTTPS support'
                    ];
                } else {
                    analysis.reason = 'HTTP URL that might support HTTPS upgrade';
                    analysis.suggestions = [
                        'Try HTTPS upgrade first',
                        'Fallback to proxy methods if HTTPS fails'
                    ];
                }
            }
            
            return analysis;
        }

        function init() {
            loadStateFromStorage();
            initTheme();
            initVirtualScrolling();
            initNetworkMonitoring();
            renderPlaylistSelect();
            renderPlaylistManagerList();
            videoPlayer.volume = appState.volume;
            qualitySelect.value = appState.currentQuality;
            setupKeyboardShortcuts();
            setupMediaSession();
            setupVideoEventListeners();
            if (appState.activePlaylistUrl) {
                const playlist = appState.playlists.find(p => p.url === appState.activePlaylistUrl);
                if (playlist) {
                    playlistSelect.value = playlist.url;
                    epgUrlInput.value = playlist.epgUrl || '';
                    loadPlaylist();
                }
            }
        }

        function setupVideoEventListeners() {
            videoPlayer.addEventListener('loadstart', () => {
                console.log('Video load started');
            });

            videoPlayer.addEventListener('loadedmetadata', () => {
                console.log('Video metadata loaded');
            });

            videoPlayer.addEventListener('canplay', () => {
                console.log('Video can start playing');
            });

            videoPlayer.addEventListener('playing', () => {
                console.log('Video is playing');
                hideError(); // Hide any previous errors when video starts playing
            });
            
            videoPlayer.addEventListener('error', (e) => {
                const error = videoPlayer.error;
                console.error('Video element error:', error);
                
                let errorMessage = 'Unknown playback error';
                let technicalDetails = '';
                let shouldAttemptRecovery = false;
                
                if (error) {
                    switch(error.code) {
                        case MediaError.MEDIA_ERR_ABORTED:
                            errorMessage = 'Video playback was aborted';
                            technicalDetails = 'The video download was cancelled';
                            break;
                        case MediaError.MEDIA_ERR_NETWORK:
                            errorMessage = 'Network error occurred while loading video';
                            technicalDetails = 'Check your internet connection and stream URL';
                            shouldAttemptRecovery = true;
                            break;
                        case MediaError.MEDIA_ERR_DECODE:
                            errorMessage = 'Video format error detected';
                            technicalDetails = 'Media decode error - attempting recovery';
                            shouldAttemptRecovery = true;
                            
                            // Attempt HLS.js media recovery if available
                            if (window.hls && typeof window.hls.recoverMediaError === 'function') {
                                console.log('Attempting HLS.js media error recovery...');
                                try {
                                    window.hls.recoverMediaError();
                                    showError('Attempting to recover from playback error...');
                                    return; // Don't show final error yet, let recovery attempt complete
                                } catch (recoveryError) {
                                    console.error('HLS.js recovery failed:', recoveryError);
                                }
                            }
                            break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMessage = 'Video source not supported';
                            technicalDetails = 'The video format or URL is not valid';
                            shouldAttemptRecovery = true;
                            break;
                        default:
                            errorMessage = `Media error (code: ${error.code})`;
                            technicalDetails = error.message || 'Unknown media error';
                            shouldAttemptRecovery = error.code !== MediaError.MEDIA_ERR_ABORTED;
                    }
                }
                
                // Log technical details for debugging
                console.log(`Technical details: ${technicalDetails}`);
                if (window.debugState) {
                    debugState.lastError = `${errorMessage} (${technicalDetails})`;
                    updateDebugInfo();
                }
                
                // Show user-friendly error message
                showError(errorMessage);
                updateStatus('error', 'Playback error');
                
                // Don't retry for authentication errors or network errors that won't be fixed by retrying
                const isAuthError = errorMessage.includes('Unauthorized') || errorMessage.includes('401');
                const isNetworkError = errorMessage.includes('ERR_NETWORK') || errorMessage.includes('ERR_INTERNET_DISCONNECTED');
                
                // Attempt recovery for recoverable errors with retry limit
                if (shouldAttemptRecovery && currentChannelIndex >= 0 && retryCount < maxRetries && !isPlaybackInProgress && !isAuthError && !isNetworkError) {
                    retryCount++;
                    console.log(`Attempting automatic error recovery... (${retryCount}/${maxRetries})`);
                    setTimeout(() => {
                        if (currentChannelIndex >= 0 && currentChannelIndex < displayedChannels.length && !isPlaybackInProgress) {
                            const channel = displayedChannels[currentChannelIndex];
                            console.log(`Retrying playback for channel: ${channel.name}`);
                            playChannel(channel.url, channel.name, channel.id);
                        }
                    }, 3000); // Wait 3 seconds before retry (increased from 2s)
                } else if (retryCount >= maxRetries) {
                    console.log('‚ùå Maximum retries reached, stopping automatic recovery');
                    showError('Stream failed to load after multiple attempts. Try a different channel or check your connection.');
                } else if (isAuthError) {
                    console.log('‚ùå Authentication error detected, not retrying');
                    showError('This stream requires authentication. Try a different channel.');
                } else if (isNetworkError) {
                    console.log('‚ùå Network error detected, not retrying');
                    showError('Network connection error. Check your internet connection.');
                }
            });

            videoPlayer.addEventListener('stalled', () => {
                console.log('Video playback stalled');
                updateStatus('loading', 'Buffering...');
            });

            videoPlayer.addEventListener('waiting', () => {
                console.log('Video waiting for data');
                updateStatus('loading', 'Buffering...');
            });            videoPlayer.addEventListener('timeupdate', () => {
                // Update status back to playing if we were buffering
                if (statusIndicator.classList.contains('status-loading') && !videoPlayer.paused) {
                    const currentChannelName = channelNameDisplay.textContent.replace('Now Playing: ', '');
                    updateStatus('online', `Playing: ${currentChannelName}`);
                }
            });

            // Save volume changes
            videoPlayer.addEventListener('volumechange', () => {
                updateAppState({ volume: videoPlayer.volume });
            });
        }

        async function loadPlaylist() {
            const playlistUrl = playlistSelect.value;
            let epgUrl = epgUrlInput.value.trim();
            if (!playlistUrl) {
                showError("Please select a playlist.");
                return;
            }

            showLoadingScreen();
            hideError();
            hideSuccess();
            resetContent();
            updateStatus('loading', 'Loading playlist...');

            try {
                // Step 1: Fetch M3U playlist
                updateLoadingScreen(
                    'Fetching Playlist...',
                    'Step 1 of 3',
                    'Downloading M3U playlist file from server',
                    'This may take a few seconds depending on server response time',
                    true,
                    10
                );

                const startTime = Date.now();
                const m3uResponse = await fetchWithProxyFallback(playlistUrl);
                const fetchTime = ((Date.now() - startTime) / 1000).toFixed(1);
                
                updateLoadingScreen(
                    'Processing Playlist...',
                    'Step 2 of 3',
                    'Parsing M3U data and extracting channel information',
                    `Downloaded in ${fetchTime}s - Processing channels...`,
                    true,
                    40
                );

                const playlistData = await m3uResponse.text();
                const parseStartTime = Date.now();
                appState.allChannels = parseM3U(playlistData, playlistUrl);
                const parseTime = ((Date.now() - parseStartTime) / 1000).toFixed(1);
                
                // Log category information for Xtreme Codes playlists and ensure EPG is set
                const playlist = appState.playlists.find(p => p.url === playlistUrl);
                if (playlist && playlist.type === 'xtreme') {
                    const categories = [...new Set(appState.allChannels.map(ch => ch.group).filter(Boolean))];
                    console.log(`üìÅ Xtreme Codes categories found (${categories.length}):`, categories.slice(0, 10));
                    
                    // Ensure EPG URL is used if available
                    if (playlist.epgUrl && !epgUrl) {
                        epgUrlInput.value = playlist.epgUrl;
                        console.log('üì∫ Auto-populated Xtreme Codes EPG URL:', playlist.epgUrl);
                        // Re-read the EPG URL now that it's been auto-populated
                        epgUrl = epgUrlInput.value.trim();
                    }
                }

                if (appState.allChannels.length === 0) {
                    throw new Error("No valid channels found in the playlist");
                }

                updateLoadingScreen(
                    'Channels Loaded!',
                    'Step 2 Complete',
                    `Found ${appState.allChannels.length} channels in playlist`,
                    `Parsed ${appState.allChannels.length} channels in ${parseTime}s`,
                    true,
                    70
                );

                // Step 3: Load EPG if provided
                if (epgUrl) {
                    console.log('üì∫ Starting EPG load for URL:', epgUrl);
                    updateLoadingScreen(
                        'Loading EPG Data...',
                        'Step 3 of 3',
                        'Downloading Electronic Program Guide (TV schedules)',
                        'This provides show information and schedules for channels',
                        true,
                        75
                    );

                    try {
                        // Validate EPG URL
                        if (!epgUrl.startsWith('http://') && !epgUrl.startsWith('https://')) {
                            throw new Error('Invalid EPG URL format. Must start with http:// or https://');
                        }

                        const epgStartTime = Date.now();
                        const epgResponse = await fetchWithProxyFallback(epgUrl);
                        
                        if (!epgResponse.ok) {
                            throw new Error(`EPG server returned error: ${epgResponse.status} ${epgResponse.statusText}`);
                        }
                        
                        const epgDataText = await epgResponse.text();
                        console.log('üì∫ EPG data received, length:', epgDataText.length);
                        
                        if (epgDataText.length < 100) {
                            throw new Error('EPG data too short, may be invalid');
                        }
                        
                        updateLoadingScreen(
                            'Processing EPG...',
                            'Step 3 of 3',
                            'Parsing TV schedule data and matching with channels',
                            'Processing program information...',
                            true,
                            90
                        );
                        
                        appState.epgData = parseXMLTV(epgDataText);
                        const epgTime = ((Date.now() - epgStartTime) / 1000).toFixed(1);
                        const epgChannelCount = Object.keys(appState.epgData).length;
                        
                        console.log(`üì∫ EPG parsing complete: ${epgChannelCount} channels with program data`);
                        
                        updateLoadingScreen(
                            'Complete!',
                            'All Steps Done',
                            `Successfully loaded ${appState.allChannels.length} channels with EPG data`,
                            `EPG loaded in ${epgTime}s for ${epgChannelCount} channels`,
                            true,
                            100
                        );
                        
                        showSuccess(`Loaded ${appState.allChannels.length} channels with EPG data for ${epgChannelCount} channels`);
                    } catch(e) {
                         console.error('‚ùå EPG loading failed:', e);
                         updateLoadingScreen(
                            'Partial Success',
                            'EPG Failed',
                            `Loaded ${appState.allChannels.length} channels (EPG data unavailable)`,
                            `EPG failed: ${e.message}`,
                            true,
                            100
                        );
                         showSuccess(`Loaded ${appState.allChannels.length} channels (EPG failed to load)`);
                    }
                } else {
                    console.log('üì∫ No EPG URL provided, skipping EPG loading');
                    updateLoadingScreen(
                        'Complete!',
                        'All Steps Done',
                        `Successfully loaded ${appState.allChannels.length} channels`,
                        'No EPG URL provided - skipping program guide',
                        true,
                        100
                    );
                    showSuccess(`Loaded ${appState.allChannels.length} channels`);
                }
                
                const currentPlaylist = appState.playlists.find(p => p.url === playlistUrl);
                if (currentPlaylist) { currentPlaylist.epgUrl = epgUrl; }
                appState.activePlaylistUrl = playlistUrl;
                saveStateToStorage();
                
                // Final update before closing
                setTimeout(() => {
                    try {
                        populateGroupFilter();
                        // Ensure grouped view is selected by default
                        groupFilter.value = 'grouped';
                        filterAndDisplayChannels();
                        updateStatus('online', 'Playlist loaded successfully');
                        console.log('‚úÖ Playlist loading completed successfully - channels organized by groups');
                    } catch (error) {
                        console.error('Error in final playlist setup:', error);
                        showError(`Error displaying channels: ${error.message}`);
                    } finally {
                        // Always hide loading screen
                        hideLoadingScreen();
                    }
                }, 800); // Give user time to see completion message
                
            } catch (error) {
                console.error('Error loading playlist:', error);
                updateLoadingScreen(
                    'Error!',
                    'Loading Failed',
                    `Failed to load playlist: ${error.message}`,
                    'Please check your internet connection and playlist URL',
                    false,
                    0
                );
                
                setTimeout(() => {
                    hideLoadingScreen();
                    showError(`Failed to load playlist: ${error.message}`);
                    updateStatus('error', 'Failed to load playlist');
                }, 2000);
            }
        }
        
        function populateGroupFilter() {
            console.log('üìã populateGroupFilter called');
            
            // Get unique groups from all channels with counts
            const groupCounts = {};
            appState.allChannels.forEach(channel => {
                const group = channel.group || 'Uncategorized';
                groupCounts[group] = (groupCounts[group] || 0) + 1;
            });
            
            // Sort groups by name, but put common groups first
            const priorityGroups = ['Sports', 'News', 'Entertainment', 'Movies', 'Kids', 'Music'];
            const groups = Object.keys(groupCounts).sort((a, b) => {
                const aPriority = priorityGroups.indexOf(a);
                const bPriority = priorityGroups.indexOf(b);
                
                if (aPriority !== -1 && bPriority !== -1) return aPriority - bPriority;
                if (aPriority !== -1) return -1;
                if (bPriority !== -1) return 1;
                return a.localeCompare(b);
            });
            
            // Clear existing options
            groupFilter.innerHTML = `
                <option value="grouped" selected>üìã Organized by Groups (${appState.allChannels.length})</option>
                <option value="">üì∫ All Channels (${appState.allChannels.length})</option>
                <option value="favorites">‚≠ê Favorites (${appState.favorites.length})</option>
                <option value="recents">üïí Recently Watched (${appState.recents.length})</option>
                <option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
            `;
            
            // Ensure default is set to grouped view
            groupFilter.value = 'grouped';
            console.log('üìã Set default view to grouped, current value:', groupFilter.value);
            
            // Add group options with emojis
            groups.forEach(group => {
                const option = document.createElement('option');
                option.value = group;
                const emoji = getGroupEmoji(group);
                option.textContent = `${emoji} ${group} (${groupCounts[group]})`;
                groupFilter.appendChild(option);
            });
            
            console.log(`üìã Added ${groups.length} groups to filter`);
        }
        
        function renderPlaylistManagerList() {
            console.log('üìã renderPlaylistManagerList called');
            
            const playlistManagerList = document.getElementById('playlist-manager-list');
            if (!playlistManagerList) return;
            
            // Clear existing list
            playlistManagerList.innerHTML = '';
            
            if (appState.playlists.length === 0) {
                playlistManagerList.innerHTML = '<p class="text-gray-400 text-center py-4">No playlists added yet</p>';
                return;
            }
            
            // Render each playlist
            appState.playlists.forEach((playlist, index) => {
                const playlistItem = document.createElement('div');
                playlistItem.className = 'bg-gray-700 rounded p-3 flex justify-between items-center';
                
                playlistItem.innerHTML = `
                    <div class="flex-grow">
                        <div class="font-medium text-white">${playlist.name}</div>
                        <div class="text-sm text-gray-400 truncate" title="${playlist.url}">${playlist.url}</div>
                        ${playlist.epgUrl ? `<div class="text-xs text-blue-400 truncate">EPG: ${playlist.epgUrl}</div>` : ''}
                    </div>
                    <button class="delete-playlist-btn bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm ml-3 flex-shrink-0" data-index="${index}" title="Delete playlist">
                        Delete
                    </button>
                `;
                
                playlistManagerList.appendChild(playlistItem);
            });
            
            // Add event listeners for delete buttons
            document.querySelectorAll('.delete-playlist-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    deletePlaylist(index);
                });
            });
            
            console.log(`üìã Rendered ${appState.playlists.length} playlists in manager`);
        }
        
        function deletePlaylist(index) {
            console.log('üóëÔ∏è deletePlaylist called:', index);
            
            if (index < 0 || index >= appState.playlists.length) {
                console.error('Invalid playlist index:', index);
                return;
            }
            
            const playlist = appState.playlists[index];
            
            // Confirm deletion
            if (!confirm(`Are you sure you want to delete "${playlist.name}"?`)) {
                return;
            }
            
            // Remove from playlists array
            appState.playlists.splice(index, 1);
            
            // If this was the active playlist, clear it
            if (appState.activePlaylistUrl === playlist.url) {
                appState.activePlaylistUrl = '';
                appState.allChannels = [];
                displayedChannels = [];
                resetContent();
            }
            
            // Update storage and UI
            saveStateToStorage();
            renderPlaylistSelect();
            renderPlaylistManagerList();
            
            showSuccess('Playlist deleted successfully');
            console.log('‚úÖ Playlist deleted:', playlist.name);
        }
        
        async function addPlaylist() {
            console.log('‚ûï addPlaylist called');
            
            // Get mode (M3U or Xtreme)
            const isXtremeMode = !document.getElementById('xtreme-fields').classList.contains('hidden');
            
            try {
                let newPlaylist;
                
                if (isXtremeMode) {
                    // Xtreme Codes mode
                    const name = document.getElementById('xtreme-playlist-name').value.trim();
                    const portalUrl = document.getElementById('xtreme-portal-url').value.trim();
                    const username = document.getElementById('xtreme-username').value.trim();
                    const password = document.getElementById('xtreme-password').value.trim();
                    
                    if (!name || !portalUrl || !username || !password) {
                        showError('Please fill in all Xtreme Codes fields');
                        return;
                    }
                    
                    // Generate M3U URL from Xtreme credentials
                    const baseUrl = portalUrl.replace(/\/$/, ''); // Remove trailing slash
                    // Use m3u8 output for better web player compatibility instead of ts
                    const m3uUrl = `${baseUrl}/get.php?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}&type=m3u_plus&output=m3u8`;
                    const epgUrl = `${baseUrl}/xmltv.php?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`;
                    
                    console.log('üîê Generated Xtreme Codes URLs:');
                    console.log('   M3U:', m3uUrl.replace(password, '***')); // Hide password in log
                    console.log('   EPG:', epgUrl.replace(password, '***'));
                    
                    newPlaylist = {
                        name: name,
                        url: m3uUrl,
                        epgUrl: epgUrl,
                        type: 'xtreme',
                        credentials: { portalUrl, username, password }
                    };
                    
                    // Clear Xtreme fields
                    document.getElementById('xtreme-playlist-name').value = '';
                    document.getElementById('xtreme-portal-url').value = '';
                    document.getElementById('xtreme-username').value = '';
                    document.getElementById('xtreme-password').value = '';
                    
                } else {
                    // M3U URL mode
                    const name = document.getElementById('new-playlist-name').value.trim();
                    const url = document.getElementById('new-playlist-url').value.trim();
                    
                    if (!name || !url) {
                        showError('Please enter both playlist name and URL');
                        return;
                    }
                    
                    // Validate URL format
                    try {
                        new URL(url);
                    } catch (e) {
                        showError('Please enter a valid URL');
                        return;
                    }
                    
                    newPlaylist = {
                        name: name,
                        url: url,
                        epgUrl: '',
                        type: 'm3u'
                    };
                    
                    // Clear M3U fields
                    document.getElementById('new-playlist-name').value = '';
                    document.getElementById('new-playlist-url').value = '';
                }
                
                // Check for duplicate URLs
                const existingPlaylist = appState.playlists.find(p => p.url === newPlaylist.url);
                if (existingPlaylist) {
                    showError(`Playlist already exists: ${existingPlaylist.name}`);
                    return;
                }
                
                // Validate Xtreme Codes URL by testing it
                if (newPlaylist.type === 'xtreme') {
                    console.log('üîê Testing Xtreme Codes URL...');
                    showLoadingScreen('Validating Xtreme Codes...', 'Testing credentials and connection...');
                    
                    const { portalUrl, username, password } = newPlaylist.credentials;
                    const baseUrl = portalUrl.replace(/\/$/, '');
                    
                    // Try multiple URL formats for better compatibility
                    // m3u_plus provides the best category support with group-title attributes
                    const urlVariants = [
                        `${baseUrl}/get.php?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}&type=m3u_plus&output=m3u8`,
                        `${baseUrl}/get.php?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}&type=m3u_plus`,
                        `${baseUrl}/get.php?username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}&type=m3u_plus&output=ts`
                    ];
                    
                    let validUrl = null;
                    
                    for (let i = 0; i < urlVariants.length; i++) {
                        const testUrl = urlVariants[i];
                        const formatName = i === 0 ? 'M3U8' : i === 1 ? 'Default' : 'TS';
                        
                        try {
                            console.log(`üîÑ Testing ${formatName} format...`);
                            const response = await fetchWithProxyFallback(testUrl);
                            const testData = await response.text();
                            
                            if (testData.includes('#EXTM3U') || testData.includes('#EXTINF')) {
                                console.log(`‚úÖ ${formatName} format works - M3U data received`);
                                validUrl = testUrl;
                                // Update the playlist URL with the working format
                                newPlaylist.url = validUrl;
                                break;
                            } else {
                                console.warn(`‚ùå ${formatName} format failed - invalid response`);
                            }
                        } catch (error) {
                            console.warn(`‚ùå ${formatName} format failed:`, error.message);
                        }
                    }
                    
                    if (validUrl) {
                        hideLoadingScreen();
                        showSuccess('Xtreme Codes playlist added successfully!');
                    } else {
                        console.error('‚ùå All Xtreme Codes URL formats failed');
                        hideLoadingScreen();
                        showError('Xtreme Codes login failed. Please check your portal URL, username, and password.');
                        return;
                    }
                }
                
                // Add to playlists
                appState.playlists.push(newPlaylist);
                saveStateToStorage();
                
                // Update UI
                renderPlaylistSelect();
                renderPlaylistManagerList();
                
                // Close modal
                document.getElementById('playlist-modal').classList.add('hidden');
                
                showSuccess(`Playlist "${newPlaylist.name}" added successfully!`);
                console.log('‚úÖ Playlist added:', newPlaylist);
                
            } catch (error) {
                console.error('‚ùå Error adding playlist:', error);
                showError(`Failed to add playlist: ${error.message}`);
            }
        }
        
        function getGroupEmoji(group) {
            const groupName = group.toLowerCase();
            if (groupName.includes('sport')) return '‚öΩ';
            if (groupName.includes('news')) return 'üì∞';
            if (groupName.includes('movie') || groupName.includes('film')) return 'üé¨';
            if (groupName.includes('music')) return 'üéµ';
            if (groupName.includes('kid') || groupName.includes('cartoon')) return 'üë∂';
            if (groupName.includes('entertain')) return 'üé≠';
            if (groupName.includes('documentary')) return 'üìΩÔ∏è';
            if (groupName.includes('lifestyle')) return 'üíÑ';
            if (groupName.includes('cooking') || groupName.includes('food')) return 'üç≥';
            if (groupName.includes('nature') || groupName.includes('animal')) return 'ü¶Å';
            if (groupName.includes('science')) return 'üî¨';
            if (groupName.includes('education')) return 'üìö';
            if (groupName.includes('religion')) return '‚õ™';
            if (groupName.includes('adult')) return 'üîû';
            return 'üì∫';
        }
        
        function getEpgForChannel(channelId) {
            const currentTime = new Date();
            
            // Check if we have EPG data
            if (!appState.epgData || Object.keys(appState.epgData).length === 0) {
                console.log('üì∫ ‚ùå No EPG data available for channel:', channelId);
                console.log('üì∫ appState.epgData type:', typeof appState.epgData, 'keys:', appState.epgData ? Object.keys(appState.epgData).length : 'null');
                return { now: null, next: null };
            }
            
            // Debug: Log EPG data availability
            const epgChannelCount = Object.keys(appState.epgData).length;
            if (Math.random() < 0.001) { // Log very occasionally to avoid spam
                console.log(`üì∫ EPG data available for ${epgChannelCount} channels, checking channel:`, channelId);
            }
            
            // Try direct match first
            let channelPrograms = appState.epgData[channelId];
            let matchMethod = 'direct';
            
            // If no direct match, try to find channel by matching ID patterns
            if (!channelPrograms) {
                // Find the channel object to get more info for matching
                const channel = appState.allChannels.find(c => c.id === channelId);
                if (channel) {
                    // Try matching by tvg-id if available
                    if (channel.tvgId && appState.epgData[channel.tvgId]) {
                        channelPrograms = appState.epgData[channel.tvgId];
                        matchMethod = 'tvg-id';
                    }
                    // Try matching by channel name (case-insensitive and fuzzy)
                    else {
                        const channelNameLower = channel.name.toLowerCase();
                        
                        // First try exact match
                        let matchingKey = Object.keys(appState.epgData).find(key => 
                            key.toLowerCase() === channelNameLower
                        );
                        
                        // Then try substring matches
                        if (!matchingKey) {
                            matchingKey = Object.keys(appState.epgData).find(key => {
                                const keyLower = key.toLowerCase();
                                return keyLower.includes(channelNameLower) || 
                                       channelNameLower.includes(keyLower);
                            });
                        }
                        
                        // Try removing common prefixes/suffixes for better matching
                        if (!matchingKey) {
                            const cleanChannelName = channelNameLower
                                .replace(/^(hd|sd|fhd|4k)\s+/i, '')
                                .replace(/\s+(hd|sd|fhd|4k)$/i, '')
                                .replace(/\s+(tv|television|channel)$/i, '')
                                .trim();
                            
                            matchingKey = Object.keys(appState.epgData).find(key => {
                                const cleanKey = key.toLowerCase()
                                    .replace(/^(hd|sd|fhd|4k)\s+/i, '')
                                    .replace(/\s+(hd|sd|fhd|4k)$/i, '')
                                    .replace(/\s+(tv|television|channel)$/i, '')
                                    .trim();
                                return cleanKey === cleanChannelName || 
                                       cleanKey.includes(cleanChannelName) || 
                                       cleanChannelName.includes(cleanKey);
                            });
                        }
                        
                        if (matchingKey) {
                            channelPrograms = appState.epgData[matchingKey];
                            matchMethod = 'name-match';
                        }
                    }
                    
                    // Debug: Log matching attempts for troubleshooting
                    if (Math.random() < 0.001) { // Very occasional logging
                        console.log(`üì∫ EPG match for "${channel.name}" (ID: ${channelId}, tvg-id: ${channel.tvgId}):`, 
                                  channelPrograms ? `‚úÖ Found via ${matchMethod}` : '‚ùå No match found');
                        if (!channelPrograms) {
                            console.log('üì∫ Available EPG channel IDs:', Object.keys(appState.epgData).slice(0, 5));
                        }
                    }
                }
            }
            
            if (!channelPrograms || channelPrograms.length === 0) {
                return { now: null, next: null };
            }
            
            // Find current and next programs
            let currentProgram = null;
            let nextProgram = null;
            
            for (let i = 0; i < channelPrograms.length; i++) {
                const program = channelPrograms[i];
                const startTime = new Date(program.start);
                const endTime = new Date(program.stop);
                
                // Check if this program is currently airing
                if (currentTime >= startTime && currentTime < endTime) {
                    currentProgram = program;
                    // Next program is the following one
                    if (i + 1 < channelPrograms.length) {
                        nextProgram = channelPrograms[i + 1];
                    }
                    break;
                }
                
                // If we haven't found current program yet, check if this is upcoming
                if (currentTime < startTime && !nextProgram) {
                    nextProgram = program;
                }
            }
            
            return {
                now: currentProgram ? `${currentProgram.title}${currentProgram.category ? ` (${currentProgram.category})` : ''}` : null,
                next: nextProgram ? `${formatTime(new Date(nextProgram.start))} - ${nextProgram.title}` : null
            };
        }
        
        function formatTime(date) {
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        // Function to validate and report EPG data status
        function validateEpgData() {
            const epgChannelCount = appState.epgData ? Object.keys(appState.epgData).length : 0;
            const totalChannels = appState.allChannels.length;
            
            console.log(`üì∫ EPG Data Status Report:`);
            console.log(`   Total channels: ${totalChannels}`);
            console.log(`   EPG channels: ${epgChannelCount}`);
            
            if (epgChannelCount === 0) {
                console.log(`   ‚ùå No EPG data available`);
                return false;
            }
            
            // Sample matching success rate
            let matchCount = 0;
            const sampleSize = Math.min(50, totalChannels);
            for (let i = 0; i < sampleSize; i++) {
                const channel = appState.allChannels[i];
                const { now, next } = getEpgForChannel(channel.id);
                if (now || next) matchCount++;
            }
            
            const matchRate = Math.round((matchCount / sampleSize) * 100);
            console.log(`   üìä Match rate: ${matchRate}% (${matchCount}/${sampleSize})`);
            
            return true;
        }
        
        // Test EPG for specific channels after category change
        function testEpgAfterCategoryChange(channelsToDisplay) {
            if (!channelsToDisplay || channelsToDisplay.length === 0) return;
            
            console.log(`üß™ Testing EPG for ${Math.min(3, channelsToDisplay.length)} channels after category change:`);
            for (let i = 0; i < Math.min(3, channelsToDisplay.length); i++) {
                const channel = channelsToDisplay[i];
                const { now, next } = getEpgForChannel(channel.id);
                console.log(`   "${channel.name}" (${channel.group}): now="${now || 'NONE'}", next="${next || 'NONE'}"`);
            }
        }
        
        async function fetchAndParseEPG(epgUrl) {
            if (!epgUrl || !epgUrl.trim()) {
                console.log('üì∫ No EPG URL provided, skipping EPG fetch');
                return;
            }
            
            console.log('üì∫ Fetching EPG data from:', epgUrl);
            
            try {
                showLoadingScreen('Loading EPG...', 'Fetching program guide data...');
                
                const response = await fetchWithProxyFallback(epgUrl);
                const xmlData = await response.text();
                
                console.log('üì∫ EPG data received, length:', xmlData.length);
                
                updateLoadingScreen('Parsing EPG...', 'Processing program guide...', 'This may take a moment for large EPG files');
                
                // Parse XMLTV format
                const epgData = parseXMLTV(xmlData);
                
                // Store EPG data
                appState.epgData = epgData;
                saveStateToStorage();
                
                console.log('‚úÖ EPG data parsed and stored');
                hideLoadingScreen();
                
                // Refresh channel display to show EPG data
                filterAndDisplayChannels();
                
                showSuccess(`EPG loaded successfully! Found program data for ${Object.keys(epgData).length} channels.`);
                
            } catch (error) {
                console.error('‚ùå Failed to fetch EPG:', error);
                hideLoadingScreen();
                showError(`Failed to load EPG: ${error.message}`);
            }
        }
        
        function parseXMLTV(xmlData) {
            console.log('üì∫ Parsing XMLTV data...');
            
            const epgData = {};
            
            try {
                // Parse XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('Invalid XML format');
                }
                
                // Get all programme elements
                const programmes = xmlDoc.querySelectorAll('programme');
                console.log(`üì∫ Found ${programmes.length} programmes in EPG`);
                
                programmes.forEach(programme => {
                    const channelId = programme.getAttribute('channel');
                    const start = programme.getAttribute('start');
                    const stop = programme.getAttribute('stop');
                    
                    if (!channelId || !start || !stop) return;
                    
                    // Parse program details
                    const titleElement = programme.querySelector('title');
                    const descElement = programme.querySelector('desc');
                    const categoryElement = programme.querySelector('category');
                    
                    const programData = {
                        start: parseXMLTVTime(start),
                        stop: parseXMLTVTime(stop),
                        title: titleElement ? titleElement.textContent.trim() : 'Unknown Program',
                        description: descElement ? descElement.textContent.trim() : '',
                        category: categoryElement ? categoryElement.textContent.trim() : ''
                    };
                    
                    // Initialize channel array if needed
                    if (!epgData[channelId]) {
                        epgData[channelId] = [];
                    }
                    
                    epgData[channelId].push(programData);
                });
                
                // Sort programs by start time for each channel
                Object.keys(epgData).forEach(channelId => {
                    epgData[channelId].sort((a, b) => new Date(a.start) - new Date(b.start));
                });
                
                console.log(`üì∫ Parsed EPG data for ${Object.keys(epgData).length} channels`);
                return epgData;
                
            } catch (error) {
                console.error('‚ùå Error parsing XMLTV:', error);
                throw new Error(`EPG parsing failed: ${error.message}`);
            }
        }
        
        function parseXMLTVTime(timeString) {
            // XMLTV time format: YYYYMMDDHHmmss +TTTT
            // Example: 20231225140000 +0000
            
            if (!timeString) return null;
            
            try {
                // Remove timezone offset for now (we'll use local time)
                const cleanTime = timeString.split(' ')[0];
                
                if (cleanTime.length >= 14) {
                    const year = cleanTime.substring(0, 4);
                    const month = cleanTime.substring(4, 6);
                    const day = cleanTime.substring(6, 8);
                    const hour = cleanTime.substring(8, 10);
                    const minute = cleanTime.substring(10, 12);
                    const second = cleanTime.substring(12, 14);
                    
                    // Create ISO string
                    const isoString = `${year}-${month}-${day}T${hour}:${minute}:${second}`;
                    return new Date(isoString).toISOString();
                }
            } catch (error) {
                console.warn('Failed to parse XMLTV time:', timeString, error);
            }
            
            return null;
        }
        
        function toggleFavorite(channelId) {
            console.log('‚≠ê toggleFavorite called:', channelId);
            
            const index = appState.favorites.indexOf(channelId);
            if (index === -1) {
                // Add to favorites
                appState.favorites.push(channelId);
                console.log('Added to favorites:', channelId);
            } else {
                // Remove from favorites
                appState.favorites.splice(index, 1);
                console.log('Removed from favorites:', channelId);
            }
            
            // Update storage and refresh display
            saveStateToStorage();
            
            // Update star icon
            const starElement = document.querySelector(`[data-channel-id="${channelId}"]`);
            if (starElement) {
                if (appState.favorites.includes(channelId)) {
                    starElement.classList.add('favorited');
                    starElement.classList.remove('text-gray-500');
                } else {
                    starElement.classList.remove('favorited');
                    starElement.classList.add('text-gray-500');
                }
            }
            
            // Update group filter counts
            populateGroupFilter();
        }
        
        async function playChannel(url, name, channelId) {
            console.log('‚ñ∂Ô∏è playChannel called:', { url, name, channelId });
            
            // Prevent multiple simultaneous playback attempts for the SAME channel
            if (isPlaybackInProgress && currentChannelName === name) {
                console.log('üö´ Playback already in progress for same channel, skipping...');
                return;
            }
            
            // Allow new channel selection to interrupt current playback
            if (isPlaybackInProgress) {
                console.log('üîÑ Interrupting current playback for new channel:', name);
                isPlaybackInProgress = false;
                // Stop current playback gracefully
                try {
                    videoPlayer.pause();
                    videoPlayer.src = '';
                    if (window.hls) {
                        window.hls.destroy();
                        window.hls = null;
                    }
                } catch (cleanupError) {
                    console.warn('Cleanup error during channel switch:', cleanupError);
                }
                // Wait a moment for cleanup to complete
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            try {
                isPlaybackInProgress = true;
                currentChannelName = name; // Set current channel name
                
                // Reset retry counter for new channel
                retryCount = 0;
                
                // Stop any existing playback and clean up
                if (videoPlayer.src) {
                    videoPlayer.pause();
                    videoPlayer.removeAttribute('src');
                    videoPlayer.load(); // Reset the video element
                }
                
                // Clean up existing HLS
                if (window.hls) {
                    window.hls.destroy();
                    window.hls = null;
                }
                
                // Update UI
                channelNameDisplay.textContent = name;
                updateStatus('loading', 'Loading stream...');
                
                // Add to recent channels
                if (channelId && !appState.recents.includes(channelId)) {
                    appState.recents.unshift(channelId);
                    // Keep only last 10 recent channels
                    appState.recents = appState.recents.slice(0, 10);
                    saveStateToStorage();
                }
                
                // Stop current stream
                if (videoPlayer.src) {
                    videoPlayer.pause();
                    videoPlayer.src = '';
                    videoPlayer.load(); // Reset video element
                }
                
                // Clean up existing HLS
                if (window.hls) {
                    window.hls.destroy();
                    window.hls = null;
                }
                
                // Try multiple playback methods in order - start with direct for better performance
                const playbackMethods = [
                    () => playDirectMethod(url, name),
                    () => playWithMultipleMethods(url, name),
                    () => playWithCorsBypass(url, name),
                    () => playWithProxyFallback(url, name),
                    () => playWithProxiedVideo(url, name)
                ];
                
                let lastError = null;
                for (let i = 0; i < playbackMethods.length; i++) {
                    const method = playbackMethods[i];
                    const methodNames = ['Direct Method', 'Multiple Methods', 'CORS Bypass', 'Proxy Fallback', 'Proxied Video'];
                    console.log(`üîÑ Trying method ${i + 1}/${playbackMethods.length}: ${methodNames[i]}`);
                    
                    try {
                        await method();
                        console.log(`‚úÖ Success with method ${i + 1}: ${methodNames[i]}`);
                        updateStatus('online', `Playing: ${name}`);
                        isPlaybackInProgress = false; // Reset flag on success
                        return; // Success!
                    } catch (error) {
                        console.warn(`‚ùå Method ${i + 1} (${methodNames[i]}) failed:`, error.message);
                        lastError = error;
                        continue;
                    }
                }
                
                // Analyze the error and provide better feedback
                const errorMessage = lastError ? lastError.message : 'Unknown error';
                const isAuthError = errorMessage.includes('401') || errorMessage.includes('Unauthorized');
                const isNetworkError = errorMessage.includes('ERR_NETWORK') || errorMessage.includes('timeout');
                const isFormatError = errorMessage.includes('Format error') || errorMessage.includes('not supported');
                const isCorsError = errorMessage.includes('CORS') || errorMessage.includes('Access-Control');
                
                if (isAuthError) {
                    throw new Error('Stream requires authentication (401 Unauthorized). This stream may need a valid subscription or login credentials.');
                } else if (isNetworkError) {
                    throw new Error('Network connectivity issue. Check your internet connection and try again.');
                } else if (isFormatError) {
                    throw new Error('Unsupported video format. This stream format may not be compatible with your browser.');
                } else if (isCorsError) {
                    throw new Error('CORS security restriction. The stream server does not allow browser access.');
                } else {
                    // Provide format-specific guidance
                    if (url.includes('.mkv')) {
                        throw new Error('MKV format detected. This format has limited browser support. Try using VLC media player.');
                    } else if (url.includes('.avi')) {
                        throw new Error('AVI format detected. This format has limited browser support. Try using VLC media player.');
                    } else if (url.includes('.ts')) {
                        throw new Error('Transport Stream format detected. This may require special handling.');
                    } else {
                        throw lastError || new Error('All playback methods failed');
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Error playing channel:', error);
                updateStatus('error', 'Failed to load stream');
                showError(`Failed to play ${name}: ${error.message}. Try refreshing or check if the stream is working in VLC.`);
            } finally {
                isPlaybackInProgress = false; // Always reset flag
            }
        }
        
        async function playDirectMethod(url, name) {
            console.log('üéØ Trying direct playback method for:', url);
            
            try {
                // For HLS streams, try direct playback first
                if (url.includes('.m3u8') || url.includes('m3u8')) {
                    if (Hls.isSupported()) {
                        const hls = new Hls({
                            xhrSetup: function(xhr, url) {
                                xhr.timeout = 10000; // 10 second timeout
                            }
                        });
                        
                        return new Promise((resolve, reject) => {
                            let resolved = false;
                            let timeoutId;
                            
                            const cleanup = () => {
                                if (timeoutId) {
                                    clearTimeout(timeoutId);
                                }
                                // Note: HLS instance cleanup is handled by caller
                            };
                            
                            hls.on(Hls.Events.MANIFEST_PARSED, () => {
                                if (!resolved) {
                                    resolved = true;
                                    cleanup();
                                    videoPlayer.play().then(resolve).catch(reject);
                                }
                            });
                            
                            hls.on(Hls.Events.ERROR, (event, data) => {
                                if (!resolved && data.fatal) {
                                    resolved = true;
                                    cleanup();
                                    reject(new Error(`HLS error: ${data.type} - ${data.details}`));
                                }
                            });
                            
                            hls.loadSource(url);
                            hls.attachMedia(videoPlayer);
                            window.hls = hls;
                            
                            // Timeout fallback
                            timeoutId = setTimeout(() => {
                                if (!resolved) {
                                    resolved = true;
                                    cleanup();
                                    reject(new Error('Direct HLS playback timeout'));
                                }
                            }, 10000);
                        });
                    }
                }
                
                // For other stream types, try direct video element playback
                return new Promise((resolve, reject) => {
                    let resolved = false;
                    let timeoutId;
                    
                    const onLoadStart = () => {
                        console.log('üéØ Direct playback started');
                    };
                    
                    const onCanPlay = () => {
                        if (!resolved) {
                            resolved = true;
                            cleanup();
                            videoPlayer.play().then(resolve).catch(reject);
                        }
                    };
                    
                    const onError = () => {
                        if (!resolved) {
                            resolved = true;
                            cleanup();
                            reject(new Error('Direct playback failed'));
                        }
                    };
                    
                    const cleanup = () => {
                        videoPlayer.removeEventListener('loadstart', onLoadStart);
                        videoPlayer.removeEventListener('canplay', onCanPlay);
                        videoPlayer.removeEventListener('error', onError);
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                        }
                    };
                    
                    videoPlayer.addEventListener('loadstart', onLoadStart);
                    videoPlayer.addEventListener('canplay', onCanPlay);
                    videoPlayer.addEventListener('error', onError);
                    
                    videoPlayer.src = url;
                    
                    // Timeout fallback
                    timeoutId = setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            cleanup();
                            reject(new Error('Direct playback timeout'));
                        }
                    }, 8000);
                });
                
            } catch (error) {
                console.warn('Direct method failed:', error);
                throw error;
            }
        }
        
        async function playWithMultipleMethods(url, name) {
            console.log('üé¨ Trying multiple playback methods for:', url);
            
            // Method 1: Direct playback (works for many streams)
            try {
                if (url.includes('.m3u8')) {
                    await playHLSStreamDirect(url, name);
                } else {
                    await playDirectStreamDirect(url, name);
                }
                return;
            } catch (error) {
                console.warn('Direct method failed:', error);
                throw error;
            }
        }
        
        async function playWithCorsBypass(url, name) {
            console.log('üåê Trying CORS bypass methods for:', url);
            
            // Updated working CORS proxies for 2025
            const corsProxies = [
                'https://api.cors.lol/?url=',
                'https://thingproxy.freeboard.io/fetch/',
                'https://api.allorigins.win/raw?url=',
                'https://cors.eu.org/',
                'https://corsproxy.io/?'
            ];
            
            for (const proxy of corsProxies) {
                try {
                    const proxiedUrl = proxy + encodeURIComponent(url);
                    console.log('üîÑ Trying CORS proxy:', proxy);
                    
                    if (url.includes('.m3u8')) {
                        await playHLSStreamDirect(proxiedUrl, name);
                    } else {
                        await playDirectStreamDirect(proxiedUrl, name);
                    }
                    return;
                } catch (error) {
                    console.warn(`CORS proxy ${proxy} failed:`, error);
                    continue;
                }
            }
            
            throw new Error('All CORS bypass methods failed');
        }
        
        async function playWithProxiedVideo(url, name) {
            console.log('üåê Trying alternative proxy for video stream:', url);
            
            // Try different proxy services for video streams - updated working proxies
            const videoProxies = [
                'https://api.cors.lol/?url=',
                'https://corsproxy.io/?',
                'https://thingproxy.freeboard.io/fetch/'
            ];
            
            for (let i = 0; i < videoProxies.length; i++) {
                const proxy = videoProxies[i];
                const proxiedUrl = `${proxy}${encodeURIComponent(url)}`;
                console.log(`üîÑ Trying video proxy ${i + 1}/${videoProxies.length}:`, proxy);
                
                try {
                    await new Promise((resolve, reject) => {
                        videoPlayer.crossOrigin = null; // Remove CORS for proxied content
                        videoPlayer.src = proxiedUrl;
                        
                        let resolved = false;
                        
                        const onLoadStart = () => {
                            // Don't resolve immediately on loadstart - wait longer for auth errors
                            console.log(`üì∫ Video proxy ${i + 1} loading started...`);
                        };
                        
                        const onCanPlay = () => {
                            if (!resolved) {
                                console.log(`‚úÖ Video proxy ${i + 1} successful`);
                                resolved = true;
                                cleanup();
                                resolve();
                            }
                        };
                        
                        const onError = () => {
                            if (!resolved) {
                                resolved = true;
                                cleanup();
                                reject(new Error(`Video proxy ${i + 1} failed`));
                            }
                        };
                        
                        const cleanup = () => {
                            videoPlayer.removeEventListener('loadstart', onLoadStart);
                            videoPlayer.removeEventListener('canplay', onCanPlay);
                            videoPlayer.removeEventListener('error', onError);
                        };
                        
                        videoPlayer.addEventListener('loadstart', onLoadStart);
                        videoPlayer.addEventListener('canplay', onCanPlay);
                        videoPlayer.addEventListener('error', onError);
                        
                        setTimeout(() => {
                            if (!resolved) {
                                resolved = true;
                                cleanup();
                                reject(new Error(`Video proxy ${i + 1} timeout`));
                            }
                        }, 15000); // Increased timeout from 8s to 15s
                    });
                    
                    // If we get here, this proxy worked
                    return;
                    
                } catch (error) {
                    console.log(`‚ùå Video proxy ${i + 1} failed:`, error.message);
                    continue;
                }
            }
            
            throw new Error('All video proxy methods failed');
        }
        
        async function playWithProxyFallback(url, name) {
            console.log('üîÑ Trying server proxy fallback for:', url);
            
            // Use our own proxy server (if available)
            try {
                const response = await fetch('/api/proxy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                
                if (response.ok) {
                    const { proxiedUrl } = await response.json();
                    if (url.includes('.m3u8')) {
                        await playHLSStreamDirect(proxiedUrl, name);
                    } else {
                        await playDirectStreamDirect(proxiedUrl, name);
                    }
                    return;
                }
            } catch (error) {
                console.warn('Server proxy failed:', error);
            }
            
            throw new Error('Server proxy not available');
        }
        
        async function playHLSStreamDirect(url, name) {
            console.log('üé¨ Playing HLS stream directly:', url);
            
            return new Promise((resolve, reject) => {
                if (Hls.isSupported()) {
                    window.hls = new Hls({
                        enableWorker: false,
                        lowLatencyMode: false,
                        backBufferLength: 30,
                        maxBufferLength: 60,
                        maxMaxBufferLength: 120,
                        startLevel: -1,
                        capLevelToPlayerSize: true,
                        debug: false,
                        xhrSetup: function(xhr, url) {
                            // Minimal headers to avoid CORS preflight issues
                        }
                    });
                    
                    let resolved = false;
                    
                    window.hls.loadSource(url);
                    window.hls.attachMedia(videoPlayer);
                    
                    window.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                        console.log('‚úÖ HLS manifest parsed successfully');
                        videoPlayer.play().then(() => {
                            if (!resolved) {
                                resolved = true;
                                applyQualitySettings();
                                resolve();
                            }
                        }).catch(error => {
                            console.error('‚ùå HLS play() failed:', error);
                            if (!resolved) {
                                resolved = true;
                                reject(new Error(`HLS playback failed: ${error.message}`));
                            }
                        });
                    });
                    
                    window.hls.on(Hls.Events.ERROR, (event, data) => {
                        console.error('‚ùå HLS error:', data);
                        if (data.fatal && !resolved) {
                            resolved = true;
                            window.hls.destroy();
                            window.hls = null;
                            reject(new Error(`HLS fatal error: ${data.details || data.type}`));
                        }
                    });
                    
                    // Timeout fallback
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            reject(new Error('HLS loading timeout'));
                        }
                    }, 10000);
                    
                } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                    // Safari native HLS support
                    console.log('üçé Using Safari native HLS support');
                    
                    videoPlayer.src = url;
                    videoPlayer.crossOrigin = 'anonymous';
                    
                    const onLoadStart = () => {
                        videoPlayer.removeEventListener('loadstart', onLoadStart);
                        videoPlayer.removeEventListener('error', onError);
                        resolve();
                    };
                    
                    const onError = (e) => {
                        videoPlayer.removeEventListener('loadstart', onLoadStart);
                        videoPlayer.removeEventListener('error', onError);
                        reject(new Error(`Safari HLS error: ${e.message || 'Unknown error'}`));
                    };
                    
                    videoPlayer.addEventListener('loadstart', onLoadStart);
                    videoPlayer.addEventListener('error', onError);
                    
                    videoPlayer.load();
                    videoPlayer.play().catch(error => {
                        reject(new Error(`Safari HLS play failed: ${error.message}`));
                    });
                    
                } else {
                    reject(new Error('HLS not supported in this browser'));
                }
            });
        }
        
        async function playDirectStreamDirect(url, name) {
            console.log('üì∫ Playing direct stream:', url);
            
            return new Promise((resolve, reject) => {
                // Try different CORS settings for video playback
                videoPlayer.crossOrigin = null; // Remove crossOrigin first
                videoPlayer.src = url;
                
                let resolved = false;
                
                const onLoadStart = () => {
                    console.log('üì∫ Direct stream loading started');
                    // Don't resolve immediately on loadstart - wait for canplay
                };
                
                const onCanPlay = () => {
                    console.log('‚úÖ Direct stream can play');
                    // Wait a bit longer to ensure stream is actually stable
                    setTimeout(() => {
                        if (!resolved && !videoPlayer.error) {
                            resolved = true;
                            cleanup();
                            resolve();
                        }
                    }, 1000); // Wait 1 second after canplay to verify stability
                };
                
                const onError = (e) => {
                    console.error('‚ùå Direct stream error:', e);
                    if (!resolved) {
                        resolved = true;
                        cleanup();
                        const error = videoPlayer.error;
                        const errorMsg = error ? `Media error ${error.code}: ${getMediaErrorMessage(error.code)}` : 'Unknown playback error';
                        reject(new Error(errorMsg));
                    }
                };
                
                const cleanup = () => {
                    videoPlayer.removeEventListener('loadstart', onLoadStart);
                    videoPlayer.removeEventListener('canplay', onCanPlay);
                    videoPlayer.removeEventListener('error', onError);
                };
                
                videoPlayer.addEventListener('loadstart', onLoadStart);
                videoPlayer.addEventListener('canplay', onCanPlay);
                videoPlayer.addEventListener('error', onError);
                
                // Load and play
                videoPlayer.load();
                videoPlayer.play().catch(error => {
                    if (!resolved) {
                        resolved = true;
                        cleanup();
                        reject(new Error(`Direct stream play failed: ${error.message}`));
                    }
                });
                
                // Timeout fallback - reduced timeout for faster fallback
                setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        cleanup();
                        reject(new Error('Direct stream timeout - trying fallback methods'));
                    }
                }, 5000); // Reduced from 8000 to 5000ms
            });
        }
        
        function getMediaErrorMessage(code) {
            switch(code) {
                case MediaError.MEDIA_ERR_ABORTED: return 'Playback aborted';
                case MediaError.MEDIA_ERR_NETWORK: return 'Network error';
                case MediaError.MEDIA_ERR_DECODE: return 'Decode error';
                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: return 'Source not supported';
                default: return 'Unknown error';
            }
        }
        
        function filterAndDisplayChannels() {
            const selectedGroup = groupFilter.value;
            const searchQuery = searchInput.value.toLowerCase();
            let channelsToDisplay = appState.allChannels;
            
            // Debug: Check EPG data availability when filtering
            const epgChannelCount = appState.epgData ? Object.keys(appState.epgData).length : 0;
            console.log(`üîÑ Filtering channels for group "${selectedGroup}", EPG data available for ${epgChannelCount} channels`);

            // Handle special views
            if (selectedGroup === 'favorites') {
                channelsToDisplay = appState.allChannels.filter(c => appState.favorites.includes(c.id));
            } else if (selectedGroup === 'recents') {
                channelsToDisplay = appState.recents.map(id => appState.allChannels.find(c => c.id === id)).filter(Boolean);
            } else if (selectedGroup === 'grouped') {
                // Display channels organized by groups
                displayChannelsGrouped(searchQuery);
                return;
            } else if (selectedGroup && selectedGroup !== '') {
                // Filter by specific group
                channelsToDisplay = appState.allChannels.filter(c => (c.group || 'Uncategorized') === selectedGroup);
                console.log(`üîç Filtered ${channelsToDisplay.length} channels for group "${selectedGroup}"`);
                if (channelsToDisplay.length > 0) {
                    const sampleChannel = channelsToDisplay[0];
                    const { now, next } = getEpgForChannel(sampleChannel.id);
                    console.log(`üì∫ Sample EPG for "${sampleChannel.name}" (ID: ${sampleChannel.id}): now="${now}", next="${next}"`);
                }
            }
            
            // Apply search filter
            if (searchQuery) {
                channelsToDisplay = channelsToDisplay.filter(c => c.name.toLowerCase().includes(searchQuery));
            }
            
            displayedChannels = channelsToDisplay;
            displayChannels(channelsToDisplay);
            
            // Test EPG for displayed channels after category change
            setTimeout(() => testEpgAfterCategoryChange(channelsToDisplay), 100);
        }
        
        function displayChannelsGrouped(searchQuery = '') {
            console.log('üìã Displaying channels grouped by category, total channels:', appState.allChannels.length);
            
            // Debug: Check EPG data availability for grouped display
            const epgChannelCount = appState.epgData ? Object.keys(appState.epgData).length : 0;
            console.log(`üì∫ EPG data available for grouped display: ${epgChannelCount} channels`);
            
            // Get all channels, filtered by search if provided
            let allChannels = appState.allChannels;
            if (searchQuery) {
                allChannels = allChannels.filter(c => c.name.toLowerCase().includes(searchQuery));
            }
            
            // Debug: Log sample channels to check group extraction
            if (allChannels.length > 0) {
                console.log('üìã Sample channels with groups:', allChannels.slice(0, 5).map(c => ({ name: c.name, group: c.group })));
            }
            
            // Group channels by category
            const channelsByGroup = {};
            allChannels.forEach(channel => {
                const group = channel.group || 'Uncategorized';
                if (!channelsByGroup[group]) {
                    channelsByGroup[group] = [];
                }
                channelsByGroup[group].push(channel);
            });
            
            console.log('üìã Groups found:', Object.keys(channelsByGroup).map(group => `${group} (${channelsByGroup[group].length})`));
            
            // Sort groups and channels within groups
            const priorityGroups = ['Sports', 'News', 'Entertainment', 'Movies', 'Kids', 'Music'];
            const sortedGroups = Object.keys(channelsByGroup).sort((a, b) => {
                const aPriority = priorityGroups.indexOf(a);
                const bPriority = priorityGroups.indexOf(b);
                
                if (aPriority !== -1 && bPriority !== -1) return aPriority - bPriority;
                if (aPriority !== -1) return -1;
                if (bPriority !== -1) return 1;
                return a.localeCompare(b);
            });
            
            // Clear channel list and disable virtual scrolling for grouped view
            virtualScrollState.isVirtualized = false;
            virtualContent.style.height = 'auto';
            channelList.style.transform = 'none';
            channelList.innerHTML = '';
            
            if (sortedGroups.length === 0) {
                channelList.innerHTML = '<p class="text-gray-400 col-span-full text-center">No channels found.</p>';
                return;
            }
            
            // Create flattened list with group headers
            const flatChannelList = [];
            sortedGroups.forEach(groupName => {
                const channels = channelsByGroup[groupName];
                
                // Add group header
                flatChannelList.push({
                    isGroupHeader: true,
                    groupName: groupName,
                    channelCount: channels.length
                });
                
                // Add channels sorted by name
                channels.sort((a, b) => a.name.localeCompare(b.name)).forEach(channel => {
                    flatChannelList.push(channel);
                });
            });
            
            displayedChannels = flatChannelList.filter(item => !item.isGroupHeader);
            displayFlattenedChannels(flatChannelList);
        }
        
        function displayFlattenedChannels(items) {
            items.forEach(item => {
                if (item.isGroupHeader) {
                    // Create group header
                    const groupHeader = document.createElement('div');
                    groupHeader.className = 'col-span-full bg-gradient-to-r from-blue-600 to-purple-600 rounded-lg p-4 mb-3 text-center font-bold text-xl text-white shadow-lg border-l-4 border-yellow-400';
                    const emoji = getGroupEmoji(item.groupName);
                    groupHeader.innerHTML = `
                        <div class="flex items-center justify-center space-x-3">
                            <span class="text-3xl">${emoji}</span>
                            <span>${item.groupName}</span>
                            <span class="bg-white text-blue-600 px-2 py-1 rounded-full text-sm font-medium">${item.channelCount}</span>
                        </div>
                    `;
                    channelList.appendChild(groupHeader);
                } else {
                    // Create channel item
                    const channel = item;
                    const isFavorite = appState.favorites.includes(channel.id);
                    const { now, next } = getEpgForChannel(channel.id);
                    const channelCard = document.createElement('div');
                    channelCard.className = 'channel-item bg-gray-700 rounded-lg p-3 flex flex-col justify-between cursor-pointer transition hover:bg-gray-600';
                    
                    const logoUrl = channel.logo || 'https://placehold.co/40x40/374151/ffffff?text=?';
                    const isHttpsLogo = logoUrl.startsWith('https://');
                    const primaryLogo = isHttpsLogo ? logoUrl : `${PROXIES[0]}${logoUrl}`;
                    const fallbackLogo = isHttpsLogo ? `${PROXIES[0]}${logoUrl}` : `${PROXIES[0]}${encodeURIComponent(logoUrl)}`;

                    const epgClass = now ? 'text-green-400' : 'text-gray-400';
                    const nextClass = next ? 'text-blue-400' : 'text-gray-500';
                    
                    channelCard.innerHTML = `
                        <div class="flex items-start space-x-3">
                            <img src="${primaryLogo}" 
                                 onerror="this.onerror=null;this.src='${fallbackLogo}';this.onerror=function(){this.onerror=null;this.src='https://placehold.co/40x40/374151/ffffff?text=?';};" 
                                 alt="logo" class="w-10 h-10 rounded-full object-cover bg-gray-600 flex-shrink-0">
                            <div class="flex-grow min-w-0">
                                <div class="font-semibold text-white truncate">${channel.name}</div>
                                <div class="text-xs mt-1 space-y-1">
                                    <div class="${epgClass} truncate" title="${now || 'No current program'}">
                                        <span class="inline-block w-2 h-2 bg-red-500 rounded-full mr-1 ${now ? 'animate-pulse' : 'opacity-50'}"></span>
                                        <strong>Now:</strong> ${now || 'No program info'}
                                    </div>
                                    <div class="${nextClass} truncate" title="${next || 'No upcoming program'}">
                                        <span class="inline-block w-2 h-2 bg-blue-500 rounded-full mr-1 ${next ? '' : 'opacity-50'}"></span>
                                        <strong>Next:</strong> ${next || 'No schedule'}
                                    </div>
                                </div>
                            </div>
                            <span class="favorite-star text-2xl ${isFavorite ? 'favorited' : 'text-gray-500'} flex-shrink-0" data-channel-id="${channel.id}">&#9733;</span>
                        </div>`;
                    
                    channelCard.addEventListener('click', (e) => {
                        if (e.target.classList.contains('favorite-star')) {
                            toggleFavorite(channel.id);
                            e.stopPropagation();
                        } else {
                            const channelIndex = displayedChannels.findIndex(c => c.id === channel.id);
                            currentChannelIndex = channelIndex;
                            playChannel(channel.url, channel.name, channel.id);
                            document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
                            channelCard.classList.add('active');
                        }
                    });
                    
                    channelList.appendChild(channelCard);
                }
            });
        }

        function displayChannels(channels) {
            // Reset virtual content transform and height
            virtualContent.style.height = 'auto';
            channelList.style.transform = 'none';
            
            if (channels.length === 0) {
                channelList.innerHTML = '<p class="text-gray-400 col-span-full text-center">No channels found.</p>';
                virtualScrollState.isVirtualized = false;
                return;
            }
            
            // Check if we should use virtual scrolling
            if (shouldUseVirtualScrolling(channels.length)) {
                console.log(`üöÄ Using virtual scrolling for ${channels.length} channels`);
                virtualScrollState.isVirtualized = true;
                virtualScrollState.allChannels = channels;
                virtualScrollState.visibleStart = 0;
                virtualScrollState.visibleEnd = Math.min(channels.length, virtualScrollState.buffer * virtualScrollState.columns);
                virtualScrollState.visibleChannels = channels.slice(virtualScrollState.visibleStart, virtualScrollState.visibleEnd);
                
                renderVirtualChannels();
                updateVirtualView(); // Initial render
            } else {
                console.log(`üì∫ Rendering ${channels.length} channels normally`);
                virtualScrollState.isVirtualized = false;
                displayChannelsNormal(channels);
            }
        }
        
        function displayChannelsNormal(channels) {
            channelList.innerHTML = '';
            channels.forEach(channel => {
                const isFavorite = appState.favorites.includes(channel.id);
                const { now, next } = getEpgForChannel(channel.id);
                const channelCard = document.createElement('div');
                channelCard.className = 'channel-item bg-gray-700 rounded-lg p-3 flex flex-col justify-between cursor-pointer transition hover:bg-gray-600';                
                
                // Smart logo loading: try direct first, then proxied versions
                const logoUrl = channel.logo || 'https://placehold.co/40x40/374151/ffffff?text=?';
                const isHttpsLogo = logoUrl.startsWith('https://');
                const primaryLogo = isHttpsLogo ? logoUrl : `${PROXIES[0]}${logoUrl}`;
                const fallbackLogo = isHttpsLogo ? `${PROXIES[0]}${logoUrl}` : `${PROXIES[0]}${encodeURIComponent(logoUrl)}`;

                const epgClass = now ? 'text-green-400' : 'text-gray-400';
                const nextClass = next ? 'text-blue-400' : 'text-gray-500';
                
                channelCard.innerHTML = `
                    <div class="flex items-start space-x-3">
                        <img src="${primaryLogo}" 
                             onerror="this.onerror=null;this.src='${fallbackLogo}';this.onerror=function(){this.onerror=null;this.src='https://placehold.co/40x40/374151/ffffff?text=?';};" 
                             alt="logo" class="w-10 h-10 rounded-full object-cover bg-gray-600 flex-shrink-0">
                        <div class="flex-grow min-w-0">
                            <div class="font-semibold text-white truncate">${channel.name}</div>
                            <div class="text-xs mt-1 space-y-1">
                                <div class="${epgClass} truncate" title="${now || 'No current program'}">
                                    <span class="inline-block w-2 h-2 bg-red-500 rounded-full mr-1 ${now ? 'animate-pulse' : 'opacity-50'}"></span>
                                    <strong>Now:</strong> ${now || 'No program info'}
                                </div>
                                <div class="${nextClass} truncate" title="${next || 'No upcoming program'}">
                                    <span class="inline-block w-2 h-2 bg-blue-500 rounded-full mr-1 ${next ? '' : 'opacity-50'}"></span>
                                    <strong>Next:</strong> ${next || 'No schedule'}
                                </div>
                            </div>
                        </div>
                        <span class="favorite-star text-2xl ${isFavorite ? 'favorited' : 'text-gray-500'} flex-shrink-0" data-channel-id="${channel.id}">&#9733;</span>
                    </div>`;
                
                channelCard.addEventListener('click', (e) => {
                    if (e.target.classList.contains('favorite-star')) {
                        toggleFavorite(channel.id);
                        e.stopPropagation();
                    } else {
                        const channelIndex = displayedChannels.findIndex(c => c.id === channel.id);
                        currentChannelIndex = channelIndex;
                        playChannel(channel.url, channel.name, channel.id);
                        document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
                        channelCard.classList.add('active');
                    }
                });
                channelList.appendChild(channelCard);
            });
        }
        
        // --- PLAYLIST UI RENDERING ---
        function renderPlaylistSelect() {
            // Clear existing options
            playlistSelect.innerHTML = '<option value="">Select a playlist...</option>';
            
            // Add all stored playlists
            appState.playlists.forEach(playlist => {
                const option = document.createElement('option');
                option.value = playlist.url;
                option.textContent = playlist.name;
                playlistSelect.appendChild(option);
            });
            
            console.log(`Rendered ${appState.playlists.length} playlists in dropdown`);
        }

        function renderPlaylistManagerList() {
            const playlistList = document.getElementById('playlist-list');
            if (!playlistList) return;
            
            // Clear existing list
            playlistList.innerHTML = '';
            
            if (appState.playlists.length === 0) {
                playlistList.innerHTML = '<p class="text-gray-400 text-center py-4">No playlists added yet</p>';
                return;
            }
            
            // Render each playlist
            appState.playlists.forEach((playlist, index) => {
                const playlistItem = document.createElement('div');
                playlistItem.className = 'bg-gray-700 rounded p-3 flex justify-between items-center';
                
                playlistItem.innerHTML = `
                    <div>
                        <div class="font-medium">${playlist.name}</div>
                        <div class="text-sm text-gray-400">${playlist.url}</div>
                    </div>
                    <button class="delete-playlist-btn bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm" data-index="${index}">
                        Delete
                    </button>
                `;
                
                playlistList.appendChild(playlistItem);
            });
            
            // Add event listeners for delete buttons
            document.querySelectorAll('.delete-playlist-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    deletePlaylist(index);
                });
            });
            
            console.log(`Rendered ${appState.playlists.length} playlists in manager`);
        }

        function deletePlaylist(index) {
            if (index >= 0 && index < appState.playlists.length) {
                const deletedPlaylist = appState.playlists[index];
                appState.playlists.splice(index, 1);
                
                // Clear active playlist if it was deleted
                if (appState.activePlaylistUrl === deletedPlaylist.url) {
                    appState.activePlaylistUrl = '';
                    playlistSelect.value = '';
                }
                
                updateAppState({ playlists: appState.playlists, activePlaylistUrl: appState.activePlaylistUrl });
                renderPlaylistSelect();
                renderPlaylistManagerList();
                
                console.log(`Deleted playlist: ${deletedPlaylist.name}`);
            }
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Only handle shortcuts if not typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    // Handle Ctrl+F for search even in input fields
                    if (e.ctrlKey && e.key === 'f') {
                        e.preventDefault();
                        searchInput.focus();
                        searchInput.select();
                    }
                    return;
                }
                
                switch(e.key) {
                    case 'f':
                    case 'F':
                        if (!e.ctrlKey) {
                            toggleFullscreen();
                        }
                        break;
                    case 'p':
                    case 'P':
                        togglePictureInPicture();
                        break;
                    case ' ':
                        e.preventDefault();
                        if (videoPlayer.paused) {
                            videoPlayer.play();
                        } else {
                            videoPlayer.pause();
                        }
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        videoPlayer.volume = Math.min(1, videoPlayer.volume + 0.1);
                        updateAppState({ volume: videoPlayer.volume });
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        videoPlayer.volume = Math.max(0, videoPlayer.volume - 0.1);
                        updateAppState({ volume: videoPlayer.volume });
                        break;
                    case 't':
                    case 'T':
                        toggleTheme();
                        break;
                    case 'Escape':
                        // Hide loading screen if visible
                        if (!loaderOverlay.classList.contains('hidden')) {
                            hideLoadingScreen();
                        }
                        break;
                }
                
                // Handle Ctrl+F for search
                if (e.ctrlKey && e.key === 'f') {
                    e.preventDefault();
                    searchInput.focus();
                    searchInput.select();
                }
            });
            
            console.log('Keyboard shortcuts initialized');
        }

        function setupMediaSession() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => {
                    videoPlayer.play();
                });
                
                navigator.mediaSession.setActionHandler('pause', () => {
                    videoPlayer.pause();
                });
                
                navigator.mediaSession.setActionHandler('stop', () => {
                    videoPlayer.pause();
                    videoPlayer.currentTime = 0;
                });
                
                console.log('Media session handlers set up');
            }
        }

        function updateMediaSessionMetadata(channelName, logoUrl) {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: channelName,
                    artist: 'IPTV Player',
                    album: 'Live Stream',
                    artwork: logoUrl ? [
                        { src: logoUrl, sizes: '96x96', type: 'image/png' },
                        { src: logoUrl, sizes: '128x128', type: 'image/png' },
                        { src: logoUrl, sizes: '192x192', type: 'image/png' },
                        { src: logoUrl, sizes: '256x256', type: 'image/png' }
                    ] : []
                });
            }
        }

        /**
         * Validates a stream URL and ensures it uses HTTP/HTTPS protocol
         * @param {string} url - The URL to validate
         * @returns {string} - The validated and cleaned URL
         * @throws {Error} - If the URL is invalid or uses unsupported protocol
         */
        function validateUrl(url) {
            if (!url || typeof url !== 'string') {
                throw new Error('Invalid URL: URL must be a non-empty string');
            }
            
            // Remove any leading/trailing whitespace
            const cleanUrl = url.trim();
            
            if (!cleanUrl) {
                throw new Error('Invalid URL: URL cannot be empty');
            }
            
            try {
                const urlObj = new URL(cleanUrl);
                
                // Check if protocol is supported
                if (!['http:', 'https:'].includes(urlObj.protocol)) {
                    throw new Error(`Unsupported protocol: ${urlObj.protocol}. Only HTTP and HTTPS URLs are supported.`);
                }
                
                return cleanUrl;
            } catch (error) {
                if (error.message.includes('Unsupported protocol')) {
                    throw error;
                }
                throw new Error(`Invalid URL format: ${cleanUrl}. Please ensure the URL is properly formatted (e.g., http://example.com/stream.m3u8)`);
            }
        }        /**
         * Attempts to upgrade an HTTP URL to HTTPS and play the stream
         * @param {string} url - The original HTTP URL
         * @param {string} name - Channel name
         * @param {string} channelId - Channel ID
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */        async function tryHttpsUpgrade(url, name, channelId) {
            console.log('üîí Attempting HTTPS upgrade for mixed content resolution...');
            
            // Only attempt if URL is HTTP
            if (!url.startsWith('http://')) {
                console.log('URL is not HTTP, skipping HTTPS upgrade');
                return false;
            }
            
            try {
                const httpsUrl = url.replace('http://', 'https://');
                console.log(`üîÑ Upgrading URL: ${url} -> ${httpsUrl}`);
                
                updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Testing', 'Checking if HTTPS version exists');
                
                // Test if HTTPS version is accessible with reduced timeout and better error handling
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                
                try {
                    const response = await fetch(httpsUrl, {
                        method: 'HEAD',
                        mode: 'cors',
                        cache: 'no-store',
                        credentials: 'omit',
                        signal: controller.signal,
                        headers: {
                            'Accept': '*/*'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        console.log(`‚ùå HTTPS upgrade failed: HTTP ${response.status} ${response.statusText}`);
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', `Server returned ${response.status} - HTTPS not supported`);
                        return false;
                    }
                    
                    console.log('‚úÖ HTTPS version is accessible, attempting playback...');
                    updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Success', 'HTTPS version accessible');
                    
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    
                    // Common HTTPS upgrade failure scenarios
                    if (fetchError.name === 'AbortError') {
                        console.log('‚ùå HTTPS upgrade timeout - server likely doesn\'t support HTTPS');
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'Timeout - HTTPS not supported');
                    } else if (fetchError.message.includes('net::ERR_SSL') || fetchError.message.includes('SSL')) {
                        console.log('‚ùå HTTPS upgrade failed - SSL/TLS certificate issues');
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'SSL certificate error');
                    } else if (fetchError.message.includes('net::ERR_CONNECTION_REFUSED')) {
                        console.log('‚ùå HTTPS upgrade failed - server doesn\'t accept HTTPS connections');
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'HTTPS port not available');
                    } else {
                        console.log('‚ùå HTTPS upgrade failed - general network error:', fetchError.message);
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'Network error - HTTPS not available');
                    }
                    return false;
                }
                
                // Try both direct and HLS playback for HTTPS URL
                if (httpsUrl.includes('.m3u8') || httpsUrl.includes('playlist')) {
                    // Try HLS.js first for M3U8 streams
                    if (Hls.isSupported()) {
                        const hlsSuccess = await new Promise((resolve) => {
                            if (window.hls) {
                                window.hls.destroy();
                            }
                            
                            window.hls = new Hls({
                                enableWorker: true,
                                lowLatencyMode: true,
                                backBufferLength: 90,
                                xhrSetup: function(xhr, url) {
                                    // Minimal headers for HTTPS upgrade
                                    xhr.setRequestHeader('Accept', '*/*');
                                }
                            });
                            
                            const onManifestParsed = () => {
                                console.log('‚úÖ HTTPS upgrade HLS manifest loaded successfully');
                                videoPlayer.play().then(() => {
                                    updateStatus('online', `Playing: ${name} (HTTPS)`);
                                    channelNameDisplay.textContent = `Now Playing: ${name}`;
                                    updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Success', 'HLS playback started');
                                    cleanup();
                                    resolve(true);
                                }).catch(err => {
                                    console.log('‚ùå HTTPS upgrade HLS playback failed:', err);
                                    cleanup();
                                    resolve(false);
                                });
                            };
                            
                            const onError = (event, data) => {
                                console.log('‚ùå HTTPS upgrade HLS error:', data);
                                updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', `HLS error: ${data.type}`);
                                cleanup();
                                resolve(false);
                            };
                            
                            const cleanup = () => {
                                window.hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                window.hls.off(Hls.Events.ERROR, onError);
                            };
                            
                            window.hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                            window.hls.on(Hls.Events.ERROR, onError);
                            window.hls.loadSource(httpsUrl);
                            window.hls.attachMedia(videoPlayer);
                            
                            // Timeout after 15 seconds
                            setTimeout(() => {
                                cleanup();
                                if (window.hls) {
                                    window.hls.destroy();
                                    window.hls = null;
                                }
                                resolve(false);
                            }, 15000);
                        });
                        
                        if (hlsSuccess) {
                            return true;
                        }
                    }
                }
                
                // Try direct playback with HTTPS URL
                return new Promise((resolve) => {
                    videoPlayer.src = httpsUrl;
                    
                    const onCanPlay = () => {
                        console.log('‚úÖ HTTPS upgrade direct playback successful');
                        updateStatus('online', `Playing: ${name} (HTTPS)`);
                        channelNameDisplay.textContent = `Now Playing: ${name}`;
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Success', 'Direct playback started');
                        cleanup();
                        resolve(true);
                    };
                    
                    const onError = (error) => {
                        console.log('‚ùå HTTPS upgrade direct playback failed:', error);
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'Direct playback error');
                        cleanup();
                        resolve(false);
                    };
                    
                    const cleanup = () => {
                        videoPlayer.removeEventListener('canplay', onCanPlay);
                        videoPlayer.removeEventListener('error', onError);
                    };
                    
                    videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
                    videoPlayer.addEventListener('error', onError, { once: true });
                    
                    // Timeout after 15 seconds
                    setTimeout(() => {
                        cleanup();
                        resolve(false);
                    }, 15000);
                });
                
            } catch (error) {
                console.log('‚ùå HTTPS upgrade failed:', error.message);
                updateDebugInfo(httpsUrl || url, 'HTTPS Upgrade', 'Failed', `Network error: ${error.message}`);
                return false;
            }        }

        /**
         * Attempts to play a stream through a server proxy
         * @param {string} url - The stream URL
         * @param {string} name - Channel name
         * @param {string} channelId - Channel ID
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */        async function tryServerProxy(url, name, channelId) {
            console.log('üîÑ Attempting server proxy playback for HTTP stream on HTTPS page...');
            
            try {
                // Use our API proxy endpoint if available
                const proxyUrl = `/api/proxy?url=${encodeURIComponent(url)}`;
                
                updateDebugInfo(proxyUrl, 'Server Proxy', 'Testing', 'Using Vercel serverless proxy to bypass mixed content');
                
                // Test proxy availability first with a HEAD request
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                
                try {
                    const testResponse = await fetch(proxyUrl, {
                        method: 'HEAD',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!testResponse.ok) {
                        if (testResponse.status === 502 || testResponse.status === 503) {
                            console.log(`‚ùå Server proxy failed: Streaming server unreachable (${testResponse.status})`);
                            updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', 'Streaming server unreachable - common with HTTP-only IPTV servers');
                        } else {
                            console.log(`‚ùå Server proxy failed: HTTP ${testResponse.status}`);
                            updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', `Proxy error ${testResponse.status}`);
                        }
                        return false;
                    }
                    
                    console.log('‚úÖ Server proxy accessible, attempting stream playback...');
                    updateDebugInfo(proxyUrl, 'Server Proxy', 'Success', 'Proxy responding, trying playback');
                    
                } catch (proxyError) {
                    clearTimeout(timeoutId);
                    
                    if (proxyError.name === 'AbortError') {
                        console.log('‚ùå Server proxy timeout - streaming server likely slow or unreachable');
                        updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', 'Timeout - streaming server too slow');
                    } else {
                        console.log('‚ùå Server proxy network error:', proxyError.message);
                        updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', 'Network error reaching streaming server');
                    }
                    return false;
                }
                
                // Check if it's an HLS stream
                if (url.includes('.m3u8') || url.includes('playlist')) {
                    // Use HLS.js for M3U8 streams through proxy
                    if (Hls.isSupported()) {
                        return new Promise((resolve) => {
                            if (window.hls) {
                                window.hls.destroy();
                            }
                            
                            window.hls = new Hls({
                                enableWorker: true,
                                lowLatencyMode: true,
                                backBufferLength: 90
                            });
                            
                            const onManifestParsed = () => {
                                console.log('Server proxy HLS manifest loaded successfully');
                                videoPlayer.play().then(() => {
                                    updateStatus('online', `Playing: ${name} (Server Proxy)`);
                                    channelNameDisplay.textContent = `Now Playing: ${name}`;
                                    cleanup();
                                    resolve(true);
                                }).catch((error) => {
                                    console.log('Server proxy HLS playback failed:', error);
                                    cleanup();
                                    resolve(false);
                                });
                            };
                            
                            const onError = (event, data) => {
                                console.log('Server proxy HLS error:', data);
                                cleanup();
                                resolve(false);
                            };
                            
                            const cleanup = () => {
                                window.hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                window.hls.off(Hls.Events.ERROR, onError);
                            };
                            
                            window.hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                            window.hls.on(Hls.Events.ERROR, onError);
                            window.hls.loadSource(proxyUrl);
                            window.hls.attachMedia(videoPlayer);
                            
                            // Timeout after 20 seconds
                            setTimeout(() => {
                                cleanup();
                                if (window.hls) {
                                    window.hls.destroy();
                                    window.hls = null;
                                }
                                resolve(false);
                            }, 20000);
                        });
                    }
                } else {
                    // Direct proxy playback for non-HLS streams
                    videoPlayer.src = proxyUrl;
                    
                    return new Promise((resolve) => {
                        const onCanPlay = () => {
                            console.log('Server proxy direct playback successful');
                            updateStatus('online', `Playing: ${name} (Server Proxy)`);
                            channelNameDisplay.textContent = `Now Playing: ${name}`;
                            cleanup();
                            resolve(true);
                        };
                        
                        const onError = (error) => {
                            console.log('Server proxy direct playback failed:', error);
                            cleanup();
                            resolve(false);
                        };
                        
                        const cleanup = () => {
                            videoPlayer.removeEventListener('canplay', onCanPlay);
                            videoPlayer.removeEventListener('error', onError);
                        };
                        
                        videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
                        videoPlayer.addEventListener('error', onError, { once: true });
                        
                        // Timeout after 15 seconds
                        setTimeout(() => {
                            cleanup();
                            resolve(false);
                        }, 15000);
                    });
                }
                
            } catch (error) {
                console.log('Server proxy failed:', error.message);
                updateDebugInfo('', '', 'Failed', `Server proxy error: ${error.message}`);
                return false;
            }
        }

        /**
         * Attempts to play a stream through a secure CORS proxy (HTTPS)
         * @param {string} url - The stream URL
         * @param {string} name - Channel name
         * @param {string} channelId - Channel ID
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */
        async function trySecureProxy(url, name, channelId) {
            console.log('Attempting secure proxy playback...');
            
            // Secure proxies for mixed content scenarios
            const secureProxies = [
                'https://cors-anywhere.herokuapp.com/',
                'https://thingproxy.freeboard.io/fetch/',
                'https://api.allorigins.win/raw?url='
            ];
            
            for (const proxy of secureProxies) {
                try {
                    console.log(`Trying secure proxy: ${proxy}`);
                    const proxyUrl = proxy + encodeURIComponent(url);
                    
                    updateDebugInfo(proxyUrl, 'Secure Proxy', `Testing ${proxy}`);
                    
                    // Test proxy availability first with a HEAD request
                    const testResponse = await fetch(proxyUrl, {
                        method: 'HEAD',
                        mode: 'cors',
                        cache: 'no-store',
                        credentials: 'omit',
                        signal: AbortSignal.timeout(8000)
                    });
                    
                    if (!testResponse.ok) {
                        console.log(`Secure proxy ${proxy} not available: HTTP ${testResponse.status}`);
                        continue;
                    }
                    
                    console.log(`Secure proxy ${proxy} is available, attempting playback...`);
                    
                    // Check if it's an HLS stream
                    if (url.includes('.m3u8') || url.includes('playlist')) {
                        // Use HLS.js for M3U8 streams through secure proxy
                        if (Hls.isSupported()) {
                            const success = await new Promise((resolve) => {
                                if (window.hls) {
                                    window.hls.destroy();
                                }
                                
                                window.hls = new Hls({
                                    enableWorker: true,
                                    lowLatencyMode: true,
                                    backBufferLength: 90,
                                    xhrSetup: function(xhr, url) {
                                        // Minimal headers for secure proxy
                                        xhr.setRequestHeader('Accept', '*/*');
                                    }
                                });
                                
                                const onManifestParsed = () => {
                                    console.log(`Secure proxy ${proxy} HLS manifest loaded`);
                                    videoPlayer.play().then(() => {
                                        updateStatus('online', `Playing: ${name} (Secure Proxy)`);
                                        channelNameDisplay.textContent = `Now Playing: ${name}`;
                                        cleanup();
                                        resolve(true);
                                    }).catch((error) => {
                                        console.log(`Secure proxy ${proxy} HLS playback failed:`, error);
                                        cleanup();
                                        resolve(false);
                                    });
                                };
                                
                                const onError = (event, data) => {
                                    console.log(`Secure proxy ${proxy} HLS error:`, data);
                                    cleanup();
                                    resolve(false);
                                };
                                
                                const cleanup = () => {
                                    window.hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                    window.hls.off(Hls.Events.ERROR, onError);
                                };
                                
                                window.hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                window.hls.on(Hls.Events.ERROR, onError);
                                window.hls.loadSource(proxyUrl);
                                window.hls.attachMedia(videoPlayer);
                                
                                // Timeout after 15 seconds
                                setTimeout(() => {
                                    cleanup();
                                    if (window.hls) {
                                        window.hls.destroy();
                                        window.hls = null;
                                    }
                                    resolve(false);
                                }, 15000);
                            });
                            
                            if (success) {
                                return true;
                            }
                        }
                    } else {
                        // Direct proxy playback for non-HLS streams
                        const success = await new Promise((resolve) => {
                            videoPlayer.src = proxyUrl;
                            
                            const onCanPlay = () => {
                                console.log(`Secure proxy ${proxy} direct playback successful`);
                                updateStatus('online', `Playing: ${name} (Secure Proxy)`);
                                channelNameDisplay.textContent = `Now Playing: ${name}`;
                                cleanup();
                                resolve(true);
                            };
                            
                            const onError = (error) => {
                                console.log(`Secure proxy ${proxy} direct playback failed:`, error);
                                                                                              cleanup();
                                resolve(false);
                            };
                            
                            const cleanup = () => {
                                videoPlayer.removeEventListener('canplay', onCanPlay);
                                videoPlayer.removeEventListener('error', onError);
                            };
                            
                            videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
                            videoPlayer.addEventListener('error', onError, { once: true });
                              // Timeout after 10 seconds
                            setTimeout(() => {
                                cleanup();
                                resolve(false);
                            }, 10000);
                        });
                        
                        if (success) {
                            return true;
                        }
                    }
                } catch (error) {
                    console.log(`Secure proxy ${proxy} failed:`, error.message);
                    updateDebugInfo('', '', 'Failed', `Secure proxy ${proxy} error: ${error.message}`);
                    // Continue to next proxy
                }
            }            console.log('All secure proxies failed');
            return false;        }

        function togglePictureInPicture() {
            if (document.pictureInPictureElement) {
                document.exitPictureInPicture().catch(err => {
                    console.error('Error exiting PIP:', err);
                });
            } else if (videoPlayer.requestPictureInPicture) {
                videoPlayer.requestPictureInPicture().catch(err => {
                    console.error('Error entering PIP:', err);
                    showError('Picture-in-Picture not supported or failed');
                });
            } else {
                showError('Picture-in-Picture not supported by this browser');
            }
        }
        
        function toggleFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen().catch(err => {
                    console.error('Error exiting fullscreen:', err);
                });
            } else if (videoPlayer.requestFullscreen) {
                videoPlayer.requestFullscreen().catch(err => {
                    console.error('Error entering fullscreen:', err);
                    showError('Fullscreen not supported or failed');
                });
            } else {
                showError('Fullscreen not supported by this browser');
            }
        }

        // --- UI FEEDBACK FUNCTIONS ---
        function showError(message, isSuccess = false) {
            console.log('üî¥ showError called:', message, 'isSuccess:', isSuccess);
            
            // Hide both messages first
            errorMessage.classList.add('hidden');
            successMessage.classList.add('hidden');
            
            if (isSuccess) {
                // Show success message
                successText.textContent = message;
                successMessage.classList.remove('hidden');
                
                // Auto-hide success messages after 3 seconds
                setTimeout(() => {
                    successMessage.classList.add('hidden');
                }, 3000);
            } else {
                // Show error message
                errorText.textContent = message;
                errorMessage.classList.remove('hidden');
                
                // Auto-hide error messages after 5 seconds
                setTimeout(() => {
                    errorMessage.classList.add('hidden');
                }, 5000);
            }
        }
        
        function showSuccess(message) {
            showError(message, true);
        }
        
        function showLoadingScreen(title = 'Loading...', details = 'Please wait...') {
            console.log('‚è≥ showLoadingScreen called:', title, details);
            
            loadingTitle.textContent = title;
            loadingDetails.textContent = details;
            loadingProgress.textContent = '';
            loadingStats.textContent = '';
            loaderOverlay.classList.remove('hidden');
        }
        
        function hideLoadingScreen() {
            console.log('‚úÖ hideLoadingScreen called');
            loaderOverlay.classList.add('hidden');
        }
        
        function updateLoadingProgress(progress, stats = '') {
            loadingProgress.textContent = progress;
            if (stats) {
                loadingStats.textContent = stats;
            }        }
        
        function hideError() {
            console.log('üî¥ hideError called');
            errorMessage.classList.add('hidden');
        }
        
        function hideSuccess() {
            console.log('‚úÖ hideSuccess called');
            successMessage.classList.add('hidden');
        }
        
        function resetContent() {
            console.log('üîÑ resetContent called');
            // Clear channels and UI state
            appState.allChannels = [];
            displayedChannels = [];
            currentChannelIndex = -1;
            
            // Reset virtual scrolling state
            virtualScrollState.isVirtualized = false;
            virtualScrollState.allChannels = [];
            virtualScrollState.visibleChannels = [];
            
            // Clear channel list
            channelList.innerHTML = '<p class="text-gray-400 col-span-full text-center">Loading channels...</p>';
            
            // Reset virtual content
            virtualContent.style.height = 'auto';
            channelList.style.transform = 'none';
            
            // Clear filters
            groupFilter.innerHTML = '<option value="">All Groups</option>';
            
            // Stop any playing video
            if (videoPlayer.src) {
                videoPlayer.pause();
                videoPlayer.src = '';
            }
            
            // Reset HLS
            if (window.hls) {
                window.hls.destroy();
                window.hls = null;
            }
            
            // Reset channel display
            channelNameDisplay.textContent = 'Select a channel to start playing';
            statusIndicator.style.display = 'none';
        }
        
        function updateLoadingScreen(title, progress, details, stats, showProgressBar, progressPercent) {
            console.log('‚è≥ updateLoadingScreen called:', title, progress, details, stats, showProgressBar, progressPercent);
            
            if (title) loadingTitle.textContent = title;
            if (progress) loadingProgress.textContent = progress;
            if (details) loadingDetails.textContent = details;
            if (stats) loadingStats.textContent = stats;
            
            if (showProgressBar && progressBarContainer) {
                progressBarContainer.classList.remove('hidden');
                if (progressPercent !== undefined && progressBar) {
                    progressBar.style.width = `${Math.max(0, Math.min(100, progressPercent))}%`;
                }
            } else if (progressBarContainer) {
                progressBarContainer.classList.add('hidden');
            }
            
            // Make sure loading screen is visible
            if (loaderOverlay) {
                loaderOverlay.classList.remove('hidden');
            }
        }

        function resetContent() {
            console.log('üîÑ resetContent called');
            // Clear channel list
            channelList.innerHTML = '<p class="text-gray-400 col-span-full text-center">Loading channels...</p>';
            
            // Reset app state
            appState.allChannels = [];
            appState.currentPlaylist = null;
            
            // Clear video
            if (videoPlayer.src) {
                videoPlayer.pause();
                videoPlayer.src = '';
                videoPlayer.load();
            }
            
            // Clean up HLS if it exists
            if (window.hls) {
                window.hls.destroy();
                window.hls = null;
            }
        }
        
        async function fetchWithProxyFallback(url) {
            console.log('üåê fetchWithProxyFallback called:', url);
            
            // Try direct fetch first
            try {
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': '*/*'
                    }
                });
                
                if (response.ok) {
                    console.log('‚úÖ Direct fetch successful');
                    return response;
                }
            } catch (error) {
                console.warn('‚ùå Direct fetch failed:', error.message);
            }
            
            // Try with proxies
            for (let i = 0; i < PROXIES.length; i++) {
                const proxy = PROXIES[i];
                const proxiedUrl = proxy + encodeURIComponent(url);
                
                try {
                    console.log(`üîÑ Trying proxy ${i + 1}/${PROXIES.length}:`, proxy);
                    const response = await fetch(proxiedUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': '*/*'
                        }
                    });
                    
                    if (response.ok) {
                        console.log(`‚úÖ Proxy fetch successful with ${proxy}`);
                        return response;
                    }
                } catch (error) {
                    console.warn(`‚ùå Proxy ${proxy} failed:`, error.message);
                    continue;
                }
            }
            
            throw new Error('All fetch methods failed. Check your network connection and playlist URL.');
        }
        
        function updateStatus(type, message) {
            console.log('üìä updateStatus called:', type, message);
            
            // Clear all status classes
            statusIndicator.classList.remove('status-online', 'status-loading', 'status-error');
            
            // Add the appropriate status class and show the indicator
            if (type === 'online') {
                statusIndicator.classList.add('status-online');
                statusIndicator.style.display = 'inline-block';
                statusIndicator.title = message || 'Online';
            } else if (type === 'loading') {
                statusIndicator.classList.add('status-loading');
                statusIndicator.style.display = 'inline-block';
                statusIndicator.title = message || 'Loading...';
            } else if (type === 'error') {
                statusIndicator.classList.add('status-error');
                statusIndicator.style.display = 'inline-block';
                statusIndicator.title = message || 'Error';
            } else {
                statusIndicator.style.display = 'none';
            }
            
            // Update debug status if available
            if (debugStatus) {
                debugStatus.textContent = message || type;
            }
        }

        // Set up event listeners
        managePlaylistsBtn.addEventListener('click', () => {
            playlistModal.style.display = 'block';
            renderPlaylistManagerList();
        });
        
        closeModalBtn.addEventListener('click', () => {
            playlistModal.style.display = 'none';
        });
        
        // Close modal when clicking outside
        playlistModal.addEventListener('click', (e) => {
            if (e.target === playlistModal) {
                playlistModal.style.display = 'none';
            }
        });
        
        // Load Playlist Button
        loadBtn.addEventListener('click', loadPlaylist);
        
        // Add Playlist Button
        addPlaylistBtn.addEventListener('click', addPlaylist);
        
        // Modal mode toggle
        m3uModeBtn.addEventListener('click', () => {
            m3uModeBtn.classList.remove('bg-gray-600');
            m3uModeBtn.classList.add('bg-blue-600');
            xtremeModeBtn.classList.remove('bg-blue-600');
            xtremeModeBtn.classList.add('bg-gray-600');
            
            m3uFields.classList.remove('hidden');
            xtremeFields.classList.add('hidden');
        });
        
        xtremeModeBtn.addEventListener('click', () => {
            xtremeModeBtn.classList.remove('bg-gray-600');
            xtremeModeBtn.classList.add('bg-blue-600');
            m3uModeBtn.classList.remove('bg-blue-600');
            m3uModeBtn.classList.add('bg-gray-600');
            
            xtremeFields.classList.remove('hidden');
            m3uFields.classList.add('hidden');
        });
        
        // Search functionality
        searchInput.addEventListener('input', (e) => {
            filterAndDisplayChannels();
        });
        
        // Group filter
        groupFilter.addEventListener('change', (e) => {
            console.log(`üîÑ Dropdown changed to: "${e.target.value}"`);
            console.log(`üì∫ EPG data before filter: ${appState.epgData ? Object.keys(appState.epgData).length : 0} channels`);
            filterAndDisplayChannels();
            
            // Validate EPG after dropdown change
            setTimeout(() => {
                console.log(`üì∫ EPG data after filter: ${appState.epgData ? Object.keys(appState.epgData).length : 0} channels`);
                validateEpgData();
            }, 200);
        });
        
        // Quality selector
        qualitySelect.addEventListener('change', (e) => {
            appState.currentQuality = e.target.value;
            saveStateToStorage();
            applyQualitySettings();
        });
        
        // Picture-in-Picture
        if (pipBtn) {
            pipBtn.addEventListener('click', togglePictureInPicture);
        }
        
        // Fullscreen
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', toggleFullscreen);
        }

        // Error and success message close buttons
        closeErrorBtn.addEventListener('click', () => {
            errorMessage.classList.add('hidden');
        });
        
        closeSuccessBtn.addEventListener('click', () => {
            successMessage.classList.add('hidden');
        });
        
        // Theme toggle
        themeToggleBtn.addEventListener('click', toggleTheme);
        
        // Loading screen click to dismiss (emergency escape)
        loaderOverlay.addEventListener('click', (e) => {
            if (e.target === loaderOverlay) {
                console.log('üîÑ Loading screen dismissed by click');
                hideLoadingScreen();
            }
        });

        // --- M3U PARSING FUNCTION ---
        /**
         * Parses M3U playlist data and extracts channel information
         * @param {string} data - The M3U playlist text content
         * @param {string} baseUrl - The playlist URL for resolving relative URLs
         * @returns {Array} - Array of channel objects
         */
        function parseM3U(data, baseUrl) {
            console.log('üîç parseM3U called with data length:', data.length);
            
            const channels = [];
            const lines = data.split('\n').map(line => line.trim()).filter(line => line);
            
            let currentChannel = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line.startsWith('#EXTINF:')) {
                    // Parse EXTINF line: #EXTINF:duration,title
                    currentChannel = {
                        id: `channel_${channels.length + 1}`,
                        name: '',
                        url: '',
                        logo: '',
                        group: 'Uncategorized',
                        duration: -1
                    };
                    
                    // Extract duration
                    const durationMatch = line.match(/#EXTINF:\s*([^,]*),/);
                    if (durationMatch) {
                        currentChannel.duration = parseFloat(durationMatch[1]) || -1;
                    }
                    
                    // Extract channel name (everything after the comma)
                    const nameMatch = line.match(/#EXTINF:[^,]*,\s*(.+)/);
                    if (nameMatch) {
                        currentChannel.name = nameMatch[1].trim();
                    }
                    
                    // Extract attributes from the EXTINF line - enhanced parsing
                    if (Math.random() < 0.01) console.log('üîç Parsing EXTINF line:', line); // Reduced logging
                    
                    // Multiple regex patterns to catch different attribute formats
                    const patterns = [
                        /(\w+[-\w]*)\s*=\s*"([^"]*)"/g,  // key="value"
                        /(\w+[-\w]*)\s*=\s*'([^']*)'/g,  // key='value'
                        /(\w+[-\w]*)\s*=\s*([^\s,]+)/g   // key=value (no quotes)
                    ];
                    
                    let foundAttributes = false;
                    
                    for (const regex of patterns) {
                        let attrMatch;
                        regex.lastIndex = 0; // Reset regex
                        
                        while ((attrMatch = regex.exec(line)) !== null) {
                            const [, key, value] = attrMatch;
                            const cleanKey = key.toLowerCase().trim();
                            const cleanValue = value.trim().replace(/^["']|["']$/g, ''); // Remove surrounding quotes
                            
                            foundAttributes = true;
                            if (Math.random() < 0.001) console.log(`üè∑Ô∏è Found attribute: ${cleanKey} = "${cleanValue}"`); // Reduced logging
                            
                            switch (cleanKey) {
                                case 'tvg-logo':
                                    currentChannel.logo = cleanValue;
                                    break;
                                case 'group-title':
                                    currentChannel.group = cleanValue;
                                    if (Math.random() < 0.001) console.log(`üìÅ Set group to: "${cleanValue}"`);
                                    break;
                                case 'tvg-name':
                                    if (!currentChannel.name) {
                                        currentChannel.name = cleanValue;
                                    }
                                    break;
                                case 'tvg-id':
                                    currentChannel.tvgId = cleanValue;
                                    break;
                            }
                        }
                    }
                    
                    // If no attributes found, try alternative parsing methods
                    if (!foundAttributes) {
                        console.log('‚ö†Ô∏è No attributes found with standard regex, trying alternative methods');
                        
                        // Look for group-title anywhere in the line
                        const groupMatch = line.match(/group-title[=:]\s*['"]*([^'",]+)['"]*[,\s]/i);
                        if (groupMatch) {
                            currentChannel.group = groupMatch[1].trim();
                            console.log(`üìÅ Found group with alternative method: "${currentChannel.group}"`);
                        }
                        
                        // Look for tvg-logo anywhere in the line
                        const logoMatch = line.match(/tvg-logo[=:]\s*['"]*([^'",\s]+)['"]*[,\s]/i);
                        if (logoMatch) {
                            currentChannel.logo = logoMatch[1].trim();
                            console.log(`üñºÔ∏è Found logo with alternative method: "${currentChannel.logo}"`);
                        }
                    }
                    
                } else if (line.startsWith('#EXTGRP:')) {
                    // Alternative group specification
                    if (currentChannel) {
                        currentChannel.group = line.substring(8).trim();
                    }
                    
                } else if (line && !line.startsWith('#') && currentChannel) {
                    // This should be the stream URL
                    let streamUrl = line.trim();
                    
                    // Resolve relative URLs
                    if (streamUrl && !streamUrl.startsWith('http')) {
                        try {
                            const base = new URL(baseUrl);
                            if (streamUrl.startsWith('/')) {
                                streamUrl = base.origin + streamUrl;
                            } else {
                                const basePath = base.pathname.substring(0, base.pathname.lastIndexOf('/') + 1);
                                streamUrl = base.origin + basePath + streamUrl;
                            }
                        } catch (e) {
                            console.warn('Failed to resolve relative URL:', streamUrl, e);
                        }
                    }
                    
                    currentChannel.url = streamUrl;
                    
                    // Set fallback name if none was found
                    if (!currentChannel.name) {
                        currentChannel.name = `Channel ${channels.length + 1}`;
                    }
                    
                    // Add the completed channel
                    channels.push(currentChannel);
                    currentChannel = null;
                }
            }
            
            console.log(`üì∫ Parsed ${channels.length} channels from M3U playlist`);
            
            // Debug: Show group distribution
            const groupStats = {};
            channels.forEach(channel => {
                const group = channel.group || 'Uncategorized';
                groupStats[group] = (groupStats[group] || 0) + 1;
            });
            
            console.log('üìä Group distribution after parsing:');
            Object.entries(groupStats).forEach(([group, count]) => {
                console.log(`  üìÅ ${group}: ${count} channels`);
            });
            
            // Show first few channels as samples
            if (channels.length > 0) {
                console.log('üìã Sample parsed channels:');
                channels.slice(0, 10).forEach((channel, index) => {
                    console.log(`  ${index + 1}. "${channel.name}" ‚Üí Group: "${channel.group}"`);
                });
            }
            
            return channels;
        }

        // --- INITIALIZATION ---
        init();
    });
    </script>
</body>
</html>
