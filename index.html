<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature-Rich M3U Streamer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">    <style>
        body { font-family: 'Inter', sans-serif; }
        #channel-list-container {
            scrollbar-width: thin;
            scrollbar-color: #4a5568 #1a202c;
        }
        #channel-list-container::-webkit-scrollbar { width: 8px; }
        #channel-list-container::-webkit-scrollbar-track { background: #1a202c; }
        #channel-list-container::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 4px; }
        .channel-item.active { background-color: #2b6cb0; box-shadow: 0 0 0 2px #60a5fa; }
        .favorite-star.favorited { color: #f6e05e; /* yellow-400 */ }
        .loader { border-top-color: #3498db; }
        
        /* Enhanced visual feedback */
        .channel-item:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .channel-item { transition: all 0.2s ease; }
        
        /* Fullscreen button styling */
        .control-btn { 
            background: rgba(0,0,0,0.6); 
            backdrop-filter: blur(4px);
            transition: all 0.2s ease;
        }
        .control-btn:hover { background: rgba(0,0,0,0.8); transform: scale(1.05); }
        
        /* Better loading animation */
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .loading-text { animation: pulse 1.5s ease-in-out infinite; }
        
        /* Mobile improvements */
        @media (max-width: 768px) {
            #channel-list { grid-template-columns: 1fr !important; }
            .channel-item { padding: 16px !important; }
        }
        
        /* Status indicators */
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-online { background-color: #10b981; }
        .status-loading { background-color: #f59e0b; animation: pulse 1s infinite; }
        .status-error { background-color: #ef4444; }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col">    <!-- Video Player Section -->
    <div class="w-full bg-black flex-shrink-0 relative group">
        <video id="video-player" class="w-full h-full max-h-[50vh]" controls preload="metadata"></video>
        <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2">
            <button id="fullscreen-btn" title="Fullscreen (F)" class="control-btn text-white p-2 rounded-full hover:bg-opacity-75">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/>
                </svg>
            </button>
            <button id="pip-btn" title="Picture-in-Picture (P)" class="control-btn text-white p-2 rounded-full hover:bg-opacity-75">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M0 3.5A1.5 1.5 0 0 1 1.5 2h13A1.5 1.5 0 0 1 16 3.5v9A1.5 1.5 0 0 1 14.5 14h-13A1.5 1.5 0 0 1 0 12.5v-9zM1.5 3a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-13z"/>
                    <path d="M8 8.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5v-3z"/>
                </svg>
            </button>
        </div>
        <div id="current-channel" class="text-center py-2 text-base font-semibold bg-gray-800 flex items-center justify-center">
            <span id="status-indicator" class="status-indicator mr-2" style="display: none;"></span>
            <span id="channel-name">Select a channel to start playing</span>
        </div>
    </div>    <!-- Controls Section -->
    <div class="flex-shrink-0 p-3 bg-gray-800 border-t border-gray-700 space-y-3">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
            <button id="manage-playlists-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2" viewBox="0 0 16 16">
                    <path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/>
                </svg>
                Manage Playlists
            </button>
            <select id="playlist-select" class="bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            <input id="epg-url" type="text" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter EPG XMLTV URL (optional)">
            <button id="load-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2" viewBox="0 0 16 16">
                    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                    <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
                </svg>
                Load Playlist
            </button>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
            <input id="search-input" type="text" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Search channels... (Ctrl+F)">
            <select id="group-filter" class="bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            <select id="quality-select" class="bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="auto">Auto Quality</option>
                <option value="high">High Quality</option>
                <option value="medium">Medium Quality</option>
                <option value="low">Low Quality</option>
            </select>
        </div>        <div class="text-xs text-gray-400 text-center flex items-center justify-between">
            <span>Shortcuts: Space (Play/Pause) • ↑↓ (Volume) • ←→ (Seek) • F (Fullscreen) • P (PiP) • Ctrl+F (Search)</span>
            <button id="debug-toggle" class="ml-4 bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white px-2 py-1 rounded text-xs transition-colors" title="Show debug info">
                Debug
            </button>
        </div>
    </div>    
    <div id="error-message" class="text-red-400 text-sm p-3 bg-red-900 border-l-4 border-red-500 hidden flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2 flex-shrink-0" viewBox="0 0 16 16">
            <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/>
        </svg>
        <span id="error-text"></span>
        <button id="close-error" class="ml-auto text-red-300 hover:text-red-100">×</button>
    </div>

    <!-- Success Message -->
    <div id="success-message" class="text-green-400 text-sm p-3 bg-green-900 border-l-4 border-green-500 hidden flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2 flex-shrink-0" viewBox="0 0 16 16">
            <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
            <path d="M10.97 4.97a.235.235 0 0 0-.02.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.061L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-1.071-1.05z"/>
        </svg>
        <span id="success-text"></span>
        <button id="close-success" class="ml-auto text-green-300 hover:text-green-100">×</button>
    </div>    <!-- Channel List -->
    <main id="channel-list-container" class="flex-grow overflow-y-auto p-3">
        <div id="channel-list" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3">
            <p class="text-gray-400 col-span-full text-center">Manage and load a playlist to get started.</p>
        </div>
    </main>

    <!-- Debug Panel -->
    <div id="debug-panel" class="fixed bottom-4 right-4 bg-gray-800 border border-gray-600 rounded-lg p-4 max-w-md hidden z-30">
        <div class="flex items-center justify-between mb-3">
            <h3 class="text-white font-semibold">Stream Debug Info</h3>
            <button id="close-debug" class="text-gray-400 hover:text-white">×</button>
        </div>
        <div id="debug-content" class="text-sm text-gray-300 space-y-2">
            <div><strong>Stream URL:</strong> <span id="debug-url" class="break-all">-</span></div>
            <div><strong>Method:</strong> <span id="debug-method">-</span></div>
            <div><strong>Status:</strong> <span id="debug-status">-</span></div>
            <div><strong>Browser Support:</strong> <span id="debug-support">-</span></div>
            <div><strong>Attempts:</strong> <span id="debug-attempts">-</span></div>
            <div><strong>Last Error:</strong> <span id="debug-error" class="text-red-400">-</span></div>
        </div>
        <div class="mt-3 space-x-2">
            <button id="debug-copy" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-xs">Copy Info</button>
            <button id="debug-test" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-xs">Test Stream</button>
        </div>
    </div><!-- Loading Spinner -->
    <div id="loader-overlay" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center hidden z-50">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24 animate-spin mb-4"></div>
        <div id="loading-title" class="text-white text-lg font-semibold loading-text mb-2">Loading playlist...</div>
        <div id="loading-progress" class="text-blue-400 text-base font-medium mb-2"></div>
        <div id="loading-details" class="text-gray-400 text-sm text-center max-w-md">
            Please wait while we fetch your channels
        </div>
        <div id="loading-stats" class="text-gray-500 text-xs mt-4 text-center"></div>
        
        <!-- Progress Bar -->
        <div class="w-80 bg-gray-700 rounded-full h-2 mt-4 hidden" id="progress-bar-container">
            <div id="progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
    </div>

    <!-- Playlist Management Modal -->    <div id="playlist-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-40">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg space-y-4">
            <h2 class="text-2xl font-bold">Manage Playlists</h2>
            <div id="playlist-manager-list" class="space-y-2 max-h-64 overflow-y-auto"></div>
            
            <!-- Playlist Type Toggle -->
            <div class="space-y-4 border-t border-gray-600 pt-4">
                <div class="flex items-center space-x-4">
                    <label class="text-sm font-medium">Playlist Type:</label>
                    <div class="flex rounded-lg overflow-hidden">
                        <button id="m3u-mode-btn" class="px-4 py-2 bg-blue-600 text-white text-sm font-medium transition-colors">M3U URL</button>
                        <button id="xtreme-mode-btn" class="px-4 py-2 bg-gray-600 text-white text-sm font-medium transition-colors">Xtreme Codes</button>
                    </div>
                </div>
                
                <!-- M3U Mode Fields -->
                <div id="m3u-fields" class="space-y-2">
                    <input type="text" id="new-playlist-name" placeholder="Playlist Name" class="w-full bg-gray-700 rounded p-2">
                    <input type="url" id="new-playlist-url" placeholder="Playlist M3U URL" class="w-full bg-gray-700 rounded p-2">
                </div>
                
                <!-- Xtreme Codes Mode Fields -->
                <div id="xtreme-fields" class="space-y-2 hidden">
                    <input type="text" id="xtreme-playlist-name" placeholder="Playlist Name" class="w-full bg-gray-700 rounded p-2">
                    <input type="url" id="xtreme-portal-url" placeholder="Portal URL (e.g., http://example.com:8080)" class="w-full bg-gray-700 rounded p-2">
                    <input type="text" id="xtreme-username" placeholder="Username" class="w-full bg-gray-700 rounded p-2">
                    <input type="password" id="xtreme-password" placeholder="Password" class="w-full bg-gray-700 rounded p-2">
                    <div class="text-xs text-gray-400 mt-1">
                        Enter your Xtreme Codes panel credentials. The system will automatically generate the M3U URL.
                    </div>
                </div>
                
                <button id="add-playlist-btn" class="w-full bg-green-600 hover:bg-green-700 p-2 rounded">Add Playlist</button>
            </div>
            <button id="close-modal-btn" class="mt-4 w-full bg-gray-600 hover:bg-gray-700 p-2 rounded">Close</button>        </div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- SECURITY CONTEXT DETECTION ---
        const isHttpsPage = window.location.protocol === 'https:';
        const isDevelopmentLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          // Store security context globally for use throughout the app
        window.securityContext = {
            isHttps: isHttpsPage,
            isDevelopment: isDevelopmentLocal,
            mixedContentBlocked: isHttpsPage && !isDevelopmentLocal,
            cspEnabled: false
        };
        
        // Check for Content Security Policy
        const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
        if (cspMeta) {
            window.securityContext.cspEnabled = true;
            console.log('🛡️ CSP detected:', cspMeta.content);
        }
        
        // Listen for CSP violations
        document.addEventListener('securitypolicyviolation', function(e) {
            console.warn('🚫 CSP Violation:', {
                blockedURI: e.blockedURI,
                violatedDirective: e.violatedDirective,
                originalPolicy: e.originalPolicy
            });
        });
        
        if (window.securityContext.isHttps && !window.securityContext.isDevelopment) {
            console.log('🔒 HTTPS page detected - Mixed Content security active');
        }
          console.log('🔍 Security Context:', window.securityContext);
        
        // --- CONSTANTS ---
        // Enhanced proxy list with development fallbacks
        const PROXIES = [
            // High-reliability public proxies (2025)
            'https://cors.eu.org/',
            'https://thingproxy.freeboard.io/fetch/',
            'https://cors.bridged.cc/',
            'https://api.cors.lol/?url=',
            // Backup public proxies
            'https://api.allorigins.win/raw?url=',
            'https://cors-proxy.fringe.zone/',
            'https://proxy-cors.isomorphic-git.org/',
            // Alternative method proxies
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://yacdn.org/proxy/'
        ];
        
        // --- DOM ELEMENTS ---
        const videoPlayer = document.getElementById('video-player');
        const currentChannelDisplay = document.getElementById('current-channel');
        const channelNameDisplay = document.getElementById('channel-name');
        const statusIndicator = document.getElementById('status-indicator');
        const loadBtn = document.getElementById('load-btn');
        const channelList = document.getElementById('channel-list');
        const searchInput = document.getElementById('search-input');
        const groupFilter = document.getElementById('group-filter');
        const qualitySelect = document.getElementById('quality-select');
        const epgUrlInput = document.getElementById('epg-url');
        const errorMessage = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        const successMessage = document.getElementById('success-message');
        const successText = document.getElementById('success-text');
        const closeErrorBtn = document.getElementById('close-error');
        const closeSuccessBtn = document.getElementById('close-success');
        const loaderOverlay = document.getElementById('loader-overlay');
        const loadingTitle = document.getElementById('loading-title');
        const loadingProgress = document.getElementById('loading-progress');
        const loadingDetails = document.getElementById('loading-details');
        const loadingStats = document.getElementById('loading-stats');
        const progressBarContainer = document.getElementById('progress-bar-container');
        const progressBar = document.getElementById('progress-bar');
        const pipBtn = document.getElementById('pip-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const managePlaylistsBtn = document.getElementById('manage-playlists-btn');
        const playlistModal = document.getElementById('playlist-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const playlistSelect = document.getElementById('playlist-select');
        const playlistManagerList = document.getElementById('playlist-manager-list');
        const addPlaylistBtn = document.getElementById('add-playlist-btn');
        const newPlaylistNameInput = document.getElementById('new-playlist-name');
        const newPlaylistUrlInput = document.getElementById('new-playlist-url');
        
        // Xtreme Codes elements
        const m3uModeBtn = document.getElementById('m3u-mode-btn');
        const xtremeModeBtn = document.getElementById('xtreme-mode-btn');
        const m3uFields = document.getElementById('m3u-fields');
        const xtremeFields = document.getElementById('xtreme-fields');
        const xtremePlaylistNameInput = document.getElementById('xtreme-playlist-name');
        const xtremePortalUrlInput = document.getElementById('xtreme-portal-url');
        const xtremeUsernameInput = document.getElementById('xtreme-username');
        const xtremePasswordInput = document.getElementById('xtreme-password');
        
        // Debug panel elements
        const debugPanel = document.getElementById('debug-panel');
        const debugToggleBtn = document.getElementById('debug-toggle');
        const closeDebugBtn = document.getElementById('close-debug');
        const debugUrl = document.getElementById('debug-url');
        const debugMethod = document.getElementById('debug-method');
        const debugStatus = document.getElementById('debug-status');
        const debugSupport = document.getElementById('debug-support');
        const debugAttempts = document.getElementById('debug-attempts');
        const debugError = document.getElementById('debug-error');
        const debugCopyBtn = document.getElementById('debug-copy');
        const debugTestBtn = document.getElementById('debug-test');
        
        // --- STATE MANAGEMENT ---
        let hls = null;
        let currentChannelIndex = -1;
        let displayedChannels = [];
        let appState = {
            allChannels: [], epgData: {}, favorites: [], recents: [],
            playlists: [], activePlaylistUrl: '', volume: 0.8, currentQuality: 'auto'
        };
        
        // --- IMAGE LOADING HELPER ---
        // Smart image URL generator that avoids double-encoding issues
        function getSmartImageUrls(imageUrl) {
            if (!imageUrl) {
                return {
                    primary: 'https://placehold.co/40x40/374151/ffffff?text=?',
                    fallback: 'https://placehold.co/40x40/374151/ffffff?text=?',
                    placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
                };
            }

            const isHttps = imageUrl.startsWith('https://');
            const isHttp = imageUrl.startsWith('http://');
            
            // For HTTPS images, try direct first (no CORS issues)
            if (isHttps) {
                return {
                    primary: imageUrl,
                    fallback: `${PROXIES[0]}${imageUrl}`, // Try proxied version as fallback
                    placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
                };
            }
            
            // For HTTP images, try proxied first (CORS + mixed content protection)
            if (isHttp) {
                return {
                    primary: `${PROXIES[0]}${imageUrl}`, // Non-encoded proxy
                    fallback: `${PROXIES[1]}${encodeURIComponent(imageUrl)}`, // Try different proxy with encoding
                    placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
                };
            }
            
            // For relative or other URLs, try to make them work
            return {
                primary: `${PROXIES[0]}${imageUrl}`,
                fallback: `${PROXIES[0]}${encodeURIComponent(imageUrl)}`,
                placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
            };
        }

        // --- CORE FUNCTIONS ---
          // Tries to fetch a URL directly first, then using a list of proxies as fallback.
        // url: The original URL to fetch
        // proxyIndex: The current proxy to try from the PROXIES array (-1 means try direct first)
        // Returns: A promise that resolves with the fetch response
        async function fetchWithProxyFallback(url, proxyIndex = -1) {
            // First try direct fetch with enhanced headers for Vercel/cloud environments
            if (proxyIndex === -1) {
                console.log(`Trying direct fetch: ${url}`);
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout for direct
                      const response = await fetch(url, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-store',
                        credentials: 'omit',
                        signal: controller.signal,
                        headers: {
                            'Accept': '*/*'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        console.log('Direct fetch successful');
                        return response;
                    }
                    console.warn(`Direct fetch failed with status: ${response.status}, trying proxies...`);
                } catch (error) {
                    console.warn('Direct fetch failed, trying proxies...', error.name || error.message);
                }
                // If direct fails, start with proxy 0
                return fetchWithProxyFallback(url, 0);
            }

            // Proxy fallback logic with enhanced error handling for Vercel
            if (proxyIndex >= PROXIES.length) {
                throw new Error(`All ${PROXIES.length} proxies failed. This stream may be incompatible with cloud deployment or require special access.

🔧 VERCEL-SPECIFIC TROUBLESHOOTING:
• Some streams are blocked in cloud environments
• Try using a VPN or different network
• Check if stream works in VLC player
• Contact stream provider for web-compatible URLs

Technical details: Network restrictions, CORS policies, or geographic blocking may prevent playback on Vercel's edge network.`);
            }
            
            const proxy = PROXIES[proxyIndex];
            const fetchUrl = proxy + (proxy.includes('?') ? encodeURIComponent(url) : url);
            
            console.log(`Trying to fetch via proxy #${proxyIndex + 1}: ${proxy.replace(/^https?:\/\//, '').split('/')[0]}`);
            
            // Update loading screen with proxy attempt info
            if (loadingDetails && proxyIndex > 0) {
                updateLoadingScreen(
                    loadingTitle.textContent,
                    loadingProgress.textContent,
                    `Trying server ${proxyIndex + 1}/${PROXIES.length}...`,
                    `Previous server failed, retrying with different proxy`,
                    !progressBarContainer.classList.contains('hidden'),
                    progressBar.style.width ? parseInt(progressBar.style.width) : 0
                );
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20s timeout for proxies
                  const response = await fetch(fetchUrl, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-store',
                    credentials: 'omit',
                    signal: controller.signal,
                    headers: {
                        'Accept': '*/*'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    console.warn(`Proxy ${proxy.replace(/^https?:\/\//, '').split('/')[0]} failed with status: ${response.status}`);
                    // Wait before trying next proxy to avoid overwhelming servers
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return fetchWithProxyFallback(url, proxyIndex + 1);
                }
                
                console.log(`Successfully fetched via proxy: ${proxy.replace(/^https?:\/\//, '').split('/')[0]}`);
                return response;
            } catch (error) {
                const errorMsg = error.name === 'AbortError' ? 'timeout' : error.message;
                console.warn(`Proxy ${proxy.replace(/^https?:\/\//, '').split('/')[0]} failed: ${errorMsg}`);
                
                // Add progressive delay between proxy attempts
                const delay = Math.min(500 + (proxyIndex * 200), 2000);
                await new Promise(resolve => setTimeout(resolve, delay));
                
                return fetchWithProxyFallback(url, proxyIndex + 1);
            }
        }
        
        /**
         * Analyzes a stream URL to provide insights about HTTPS compatibility
         * @param {string} url - The stream URL to analyze
         * @returns {object} - Analysis results
         */
        function analyzeStreamCompatibility(url) {
            const analysis = {
                isHttp: url.startsWith('http://'),
                isHttps: url.startsWith('https://'),
                likelyHttpsIncompatible: false,
                reason: '',
                suggestions: []
            };
            
            if (analysis.isHttp) {
                // Check for common IPTV/streaming patterns that are typically HTTP-only
                const httpOnlyPatterns = [
                    /:\d{4,5}\//,  // Non-standard ports (e.g., :8080/, :1935/)
                    /\/live\//,    // Live streaming endpoints
                    /\/stream\//,  // Stream endpoints
                    /\.ts$/,       // Transport stream files
                    /playlist\.m3u8/, // HLS playlists
                    /chunklist/,   // HLS chunks
                    /udp:\/\//,    // UDP streams
                    /rtmp:\/\//,   // RTMP streams
                ];
                
                analysis.likelyHttpsIncompatible = httpOnlyPatterns.some(pattern => pattern.test(url));
                
                if (analysis.likelyHttpsIncompatible) {
                    analysis.reason = 'URL contains patterns typical of HTTP-only streaming infrastructure';
                    analysis.suggestions = [
                        'Use proxy methods to bypass mixed content restrictions',
                        'Streaming servers often use HTTP due to SSL certificate costs',
                        'Consider asking provider about HTTPS support'
                    ];
                } else {
                    analysis.reason = 'HTTP URL that might support HTTPS upgrade';
                    analysis.suggestions = [
                        'Try HTTPS upgrade first',
                        'Fallback to proxy methods if HTTPS fails'
                    ];
                }
            }
            
            return analysis;
        }

        function init() {
            loadStateFromStorage();
            renderPlaylistSelect();
            renderPlaylistManagerList();
            videoPlayer.volume = appState.volume;
            qualitySelect.value = appState.currentQuality;
            setupKeyboardShortcuts();
            setupMediaSession();
            setupVideoEventListeners();
            if (appState.activePlaylistUrl) {
                const playlist = appState.playlists.find(p => p.url === appState.activePlaylistUrl);
                if (playlist) {
                    playlistSelect.value = playlist.url;
                    epgUrlInput.value = playlist.epgUrl || '';
                    loadPlaylist();
                }
            }
        }

        function setupVideoEventListeners() {
            videoPlayer.addEventListener('loadstart', () => {
                console.log('Video load started');
            });

            videoPlayer.addEventListener('loadedmetadata', () => {
                console.log('Video metadata loaded');
            });

            videoPlayer.addEventListener('canplay', () => {
                console.log('Video can start playing');
            });

            videoPlayer.addEventListener('playing', () => {
                console.log('Video is playing');
                hideError(); // Hide any previous errors when video starts playing
            });
            
            videoPlayer.addEventListener('error', (e) => {
                const error = videoPlayer.error;
                console.error('Video element error:', error);
                
                let errorMessage = 'Unknown playback error';
                let technicalDetails = '';
                let shouldAttemptRecovery = false;
                
                if (error) {
                    switch(error.code) {
                        case MediaError.MEDIA_ERR_ABORTED:
                            errorMessage = 'Video playback was aborted';
                            technicalDetails = 'The video download was cancelled';
                            break;
                        case MediaError.MEDIA_ERR_NETWORK:
                            errorMessage = 'Network error occurred while loading video';
                            technicalDetails = 'Check your internet connection and stream URL';
                            shouldAttemptRecovery = true;
                            break;
                        case MediaError.MEDIA_ERR_DECODE:
                            errorMessage = 'Video format error detected';
                            technicalDetails = 'Media decode error - attempting recovery';
                            shouldAttemptRecovery = true;
                            
                            // Attempt HLS.js media recovery if available
                            if (window.hls && typeof window.hls.recoverMediaError === 'function') {
                                console.log('Attempting HLS.js media error recovery...');
                                try {
                                    window.hls.recoverMediaError();
                                    showError('Attempting to recover from playback error...');
                                    return; // Don't show final error yet, let recovery attempt complete
                                } catch (recoveryError) {
                                    console.error('HLS.js recovery failed:', recoveryError);
                                }
                            }
                            break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMessage = 'Video source not supported';
                            technicalDetails = 'The video format or URL is not valid';
                            shouldAttemptRecovery = true;
                            break;
                        default:
                            errorMessage = `Media error (code: ${error.code})`;
                            technicalDetails = error.message || 'Unknown media error';
                            shouldAttemptRecovery = error.code !== MediaError.MEDIA_ERR_ABORTED;
                    }
                }
                
                // Log technical details for debugging
                console.log(`Technical details: ${technicalDetails}`);
                debugState.lastError = `${errorMessage} (${technicalDetails})`;
                updateDebugInfo();
                
                // Show user-friendly error message
                showError(errorMessage);
                updateStatus('error', 'Playback error');
                
                // Attempt recovery for recoverable errors
                if (shouldAttemptRecovery && currentChannelIndex >= 0) {
                    console.log('Attempting automatic error recovery...');
                    setTimeout(() => {
                        if (currentChannelIndex >= 0 && currentChannelIndex < displayedChannels.length) {
                            const channel = displayedChannels[currentChannelIndex];
                            console.log(`Retrying playback for channel: ${channel.name}`);
                            playChannel(channel.url, channel.name, channel.id);
                        }
                    }, 2000); // Wait 2 seconds before retry
                }
            });

            videoPlayer.addEventListener('stalled', () => {
                console.log('Video playback stalled');
                updateStatus('loading', 'Buffering...');
            });

            videoPlayer.addEventListener('waiting', () => {
                console.log('Video waiting for data');
                updateStatus('loading', 'Buffering...');
            });

            videoPlayer.addEventListener('timeupdate', () => {
                // Update status back to playing if we were buffering
                if (statusIndicator.classList.contains('status-loading') && !videoPlayer.paused) {
                    const currentChannelName = channelNameDisplay.textContent.replace('Now Playing: ', '');
                    updateStatus('online', `Playing: ${currentChannelName}`);
                }
            });
        }

        async function loadPlaylist() {
            const playlistUrl = playlistSelect.value;
            const epgUrl = epgUrlInput.value.trim();
            if (!playlistUrl) {
                showError("Please select a playlist.");
                return;
            }

            showLoadingScreen();
            hideError();
            hideSuccess();
            resetContent();
            updateStatus('loading', 'Loading playlist...');

            try {
                // Step 1: Fetch M3U playlist
                updateLoadingScreen(
                    'Fetching Playlist...',
                    'Step 1 of 3',
                    'Downloading M3U playlist file from server',
                    'This may take a few seconds depending on server response time',
                    true,
                    10
                );

                const startTime = Date.now();
                const m3uResponse = await fetchWithProxyFallback(playlistUrl);
                const fetchTime = ((Date.now() - startTime) / 1000).toFixed(1);
                
                updateLoadingScreen(
                    'Processing Playlist...',
                    'Step 2 of 3',
                    'Parsing M3U data and extracting channel information',
                    `Downloaded in ${fetchTime}s - Processing channels...`,
                    true,
                    40
                );

                const playlistData = await m3uResponse.text();
                const parseStartTime = Date.now();
                appState.allChannels = parseM3U(playlistData, playlistUrl);
                const parseTime = ((Date.now() - parseStartTime) / 1000).toFixed(1);

                if (appState.allChannels.length === 0) {
                    throw new Error("No valid channels found in the playlist");
                }

                updateLoadingScreen(
                    'Channels Loaded!',
                    'Step 2 Complete',
                    `Found ${appState.allChannels.length} channels in playlist`,
                    `Parsed ${appState.allChannels.length} channels in ${parseTime}s`,
                    true,
                    70
                );

                // Step 3: Load EPG if provided
                if (epgUrl) {
                    updateLoadingScreen(
                        'Loading EPG Data...',
                        'Step 3 of 3',
                        'Downloading Electronic Program Guide (TV schedules)',
                        'This provides show information and schedules for channels',
                        true,
                        75
                    );

                    try {
                        const epgStartTime = Date.now();
                        const epgResponse = await fetchWithProxyFallback(epgUrl);
                        const epgDataText = await epgResponse.text();
                        
                        updateLoadingScreen(
                            'Processing EPG...',
                            'Step 3 of 3',
                            'Parsing TV schedule data and matching with channels',
                            'Processing program information...',
                            true,
                            90
                        );
                        
                        appState.epgData = parseEPG(epgDataText);
                        const epgTime = ((Date.now() - epgStartTime) / 1000).toFixed(1);
                        const epgChannelCount = Object.keys(appState.epgData).length;
                        
                        updateLoadingScreen(
                            'Complete!',
                            'All Steps Done',
                            `Successfully loaded ${appState.allChannels.length} channels with EPG data`,
                            `EPG loaded in ${epgTime}s for ${epgChannelCount} channels`,
                            true,
                            100
                        );
                        
                        showSuccess(`Loaded ${appState.allChannels.length} channels with EPG data for ${epgChannelCount} channels`);
                    } catch(e) {
                         console.warn(`Could not load EPG: ${e.message}`);
                         updateLoadingScreen(
                            'Partial Success',
                            'EPG Failed',
                            `Loaded ${appState.allChannels.length} channels (EPG data unavailable)`,
                            `EPG failed: ${e.message}`,
                            true,
                            100
                        );
                         showSuccess(`Loaded ${appState.allChannels.length} channels (EPG failed to load)`);
                    }
                } else {
                    updateLoadingScreen(
                        'Complete!',
                        'All Steps Done',
                        `Successfully loaded ${appState.allChannels.length} channels`,
                        'No EPG URL provided - skipping program guide',
                        true,
                        100
                    );
                    showSuccess(`Loaded ${appState.allChannels.length} channels`);
                }
                
                const currentPlaylist = appState.playlists.find(p => p.url === playlistUrl);
                if (currentPlaylist) { currentPlaylist.epgUrl = epgUrl; }
                appState.activePlaylistUrl = playlistUrl;
                saveStateToStorage();
                
                // Final update before closing
                setTimeout(() => {
                    populateGroupFilter();
                    filterAndDisplayChannels();
                    updateStatus('online', 'Playlist loaded successfully');
                    hideLoadingScreen();
                }, 800); // Give user time to see completion message
                
            } catch (error) {
                console.error('Error loading playlist:', error);
                updateLoadingScreen(
                    'Error!',
                    'Loading Failed',
                    `Failed to load playlist: ${error.message}`,
                    'Please check your internet connection and playlist URL',
                    false,
                    0
                );
                
                setTimeout(() => {
                    hideLoadingScreen();
                    showError(`Failed to load playlist: ${error.message}`);
                    updateStatus('error', 'Failed to load playlist');
                }, 2000);
            }
        }
          function filterAndDisplayChannels() {
            const selectedGroup = groupFilter.value;
            const searchQuery = searchInput.value.toLowerCase();
            let channelsToDisplay = appState.allChannels;

            if (selectedGroup === 'favorites') {
                channelsToDisplay = appState.allChannels.filter(c => appState.favorites.includes(c.id));
            } else if (selectedGroup === 'recents') {
                 channelsToDisplay = appState.recents.map(id => appState.allChannels.find(c => c.id === id)).filter(Boolean);
            } else if (selectedGroup !== 'all') {
                channelsToDisplay = appState.allChannels.filter(c => c.group === selectedGroup);
            }
            if (searchQuery) {
                channelsToDisplay = channelsToDisplay.filter(c => c.name.toLowerCase().includes(searchQuery));
            }
            displayedChannels = channelsToDisplay;
            displayChannels(channelsToDisplay);
        }

        function displayChannels(channels) {
            channelList.innerHTML = '';
            if (channels.length === 0) {
                channelList.innerHTML = '<p class="text-gray-400 col-span-full text-center">No channels found.</p>';
                return;
            }
            channels.forEach(channel => {
                const isFavorite = appState.favorites.includes(channel.id);
                const { now, next } = getEpgForChannel(channel.id);
                const channelCard = document.createElement('div');
                channelCard.className = 'channel-item bg-gray-700 rounded-lg p-3 flex flex-col justify-between cursor-pointer transition hover:bg-gray-600';                // Smart logo loading: try direct first, then proxied versions
                const logoUrl = channel.logo || 'https://placehold.co/40x40/374151/ffffff?text=?';
                const isHttpsLogo = logoUrl.startsWith('https://');
                const primaryLogo = isHttpsLogo ? logoUrl : `${PROXIES[0]}${logoUrl}`;
                const fallbackLogo = isHttpsLogo ? `${PROXIES[0]}${logoUrl}` : `${PROXIES[0]}${encodeURIComponent(logoUrl)}`;

                channelCard.innerHTML = `
                    <div class="flex items-start space-x-3">
                        <img src="${primaryLogo}" 
                             onerror="this.onerror=null;this.src='${fallbackLogo}';this.onerror=function(){this.onerror=null;this.src='https://placehold.co/40x40/374151/ffffff?text=?';};" 
                             alt="logo" class="w-10 h-10 rounded-full object-cover bg-gray-600 flex-shrink-0">
                        <span class="font-semibold flex-grow">${channel.name}</span>
                        <span class="favorite-star text-2xl ${isFavorite ? 'favorited' : 'text-gray-500'}" data-channel-id="${channel.id}">&#9733;</span>
                    </div>
                    <div class="text-xs text-gray-300 mt-2 pl-13">
                        <p class="truncate" title="${now || 'No EPG data'}"><strong>Now:</strong> ${now || '...'}</p>
                        <p class="truncate" title="${next || 'No EPG data'}"><strong>Next:</strong> ${next || '...'}</p>
                    </div>`;
                
                channelCard.addEventListener('click', (e) => {
                    if (e.target.classList.contains('favorite-star')) {
                        toggleFavorite(channel.id);
                        e.stopPropagation();
                    } else {
                        const channelIndex = displayedChannels.findIndex(c => c.id === channel.id);
                        currentChannelIndex = channelIndex;
                        playChannel(channel.url, channel.name, channel.id);
                        document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
                        channelCard.classList.add('active');
                    }
                });
                channelList.appendChild(channelCard);
            });
        }
        
        function convertXtremeCodesUrl(url) {
            // Handle Xtreme Codes .ts URLs by converting to M3U8 playlist
            if (url.includes('.ts') && !url.includes('.m3u8')) {
                // Check if this looks like an Xtreme Codes stream URL
                // Format: http://server:port/username/password/streamid.ts
                const tsRegex = /^(https?:\/\/[^\/]+\/[^\/]+\/[^\/]+\/)(\d+)\.ts$/;
                const match = url.match(tsRegex);
                
                if (match) {
                    // Convert to M3U8 URL: http://server:port/username/password/streamid.m3u8
                    const m3u8Url = match[1] + match[2] + '.m3u8';
                    console.log(`Converting Xtreme Codes .ts URL to M3U8: ${url} -> ${m3u8Url}`);
                    return m3u8Url;
                }
                
                // Alternative format check: look for numeric stream ID at the end
                const altRegex = /^(.+\/)(\d+)\.ts$/;
                const altMatch = url.match(altRegex);
                
                if (altMatch) {
                    const m3u8Url = altMatch[1] + altMatch[2] + '.m3u8';
                    console.log(`Converting alternative .ts URL to M3U8: ${url} -> ${m3u8Url}`);
                    return m3u8Url;                }
            }
            
            return url; // Return original URL if no conversion needed
        }

        function playChannel(url, name, channelId) {
            if (hls) hls.destroy();
            updateStatus('loading', `Loading ${name}...`);
            
            // Reset debug state for new channel
            resetDebugState();
            updateDebugInfo(url, 'Initializing', 'Starting playback');
            
            // Clean and validate the URL
            let cleanUrl;
            try {
                cleanUrl = validateUrl(url.trim());
            } catch (error) {
                showError(error.message);
                updateStatus('error', 'Invalid URL');
                updateDebugInfo('', '', 'Failed', error.message);
                return;
            }

            // Convert Xtreme Codes .ts URLs to M3U8
            const convertedUrl = convertXtremeCodesUrl(cleanUrl);
            if (convertedUrl !== cleanUrl) {
                console.log(`URL converted from .ts to M3U8: ${cleanUrl} -> ${convertedUrl}`);
                updateDebugInfo(convertedUrl, 'URL Conversion', 'Converted .ts to M3U8');
            }
            
            console.log(`Attempting to play: ${convertedUrl}`);
            channelNameDisplay.textContent = `Loading: ${name}`;
            addRecent(channelId);
            updateMediaSession(name);
            
            // Enhanced playback strategy with better fallbacks
            playWithFallbackStrategy(convertedUrl, name, channelId);
        }

        async function playWithFallbackStrategy(url, name, channelId) {
            console.log(`🚀 Starting UNIVERSAL playback strategy for: ${url}`);
            resetDebugState();
            
            // Universal approach - try ALL methods regardless of URL type
            const isHttpUrl = url.startsWith('http://');
            const isHttpsPage = window.location.protocol === 'https:';
            const hasMixedContentIssue = isHttpUrl && isHttpsPage;
            
            if (hasMixedContentIssue) {
                console.warn('🔒 Mixed Content detected - will try ALL available methods to make this stream work');
                showError('🔒 Mixed Content detected - trying all available methods to bypass browser restrictions...');
            } else {
                console.log('🎯 Direct playback possible - will still try all methods if needed');
            }
            
            // COMPREHENSIVE strategy list - try EVERYTHING
            let strategies = [];
            
            if (hasMixedContentIssue) {
                // For mixed content, start with proxy methods that are most likely to work
                strategies = [
                    { name: 'Vercel Proxy + HLS.js', method: () => tryServerProxy(url, name, channelId) },
                    { name: 'Secure Proxy (cors-anywhere)', method: () => trySecureProxy(url, name, channelId) },
                    { name: 'External Proxy Network', method: () => tryProxiedPlayback(url, name, channelId) },
                    { name: 'HTTPS Upgrade (if compatible)', method: () => tryHttpsUpgrade(url, name, channelId) },
                    { name: 'Direct + HLS.js (force attempt)', method: () => tryHlsPlayback(url, name, channelId) },
                    { name: 'Native Browser HLS', method: () => tryNativeHlsPlayback(url, name, channelId) },
                    { name: 'Direct Stream (last resort)', method: () => tryDirectPlayback(url, name, channelId) }
                ];
            } else {
                // For non-mixed content, start with direct methods but still have full fallback
                strategies = [
                    { name: 'Direct Stream', method: () => tryDirectPlayback(url, name, channelId) },
                    { name: 'HLS.js Enhanced', method: () => tryHlsPlayback(url, name, channelId) },
                    { name: 'Native Browser HLS', method: () => tryNativeHlsPlayback(url, name, channelId) },
                    { name: 'Vercel Proxy Backup', method: () => tryServerProxy(url, name, channelId) },
                    { name: 'Secure Proxy Backup', method: () => trySecureProxy(url, name, channelId) },
                    { name: 'External Proxy Network', method: () => tryProxiedPlayback(url, name, channelId) },
                    { name: 'HTTPS Upgrade (if needed)', method: () => tryHttpsUpgrade(url, name, channelId) }
                ];            }
            
            // Try each strategy until one works
            for (let i = 0; i < strategies.length; i++) {
                const strategy = strategies[i];
                console.log(`Trying strategy ${i + 1}/${strategies.length}: ${strategy.name}`);
                updateStatus('loading', `Trying ${strategy.name}...`);
                updateDebugInfo(url, strategy.name, 'Attempting connection');
                
                try {
                    const success = await strategy.method();
                    if (success) {
                        console.log(`✅ Success with strategy: ${strategy.name}`);
                        updateDebugInfo(url, strategy.name, 'Success', 'Playback started successfully');
                        hideError(); // Hide mixed content warning on success
                        return;
                    }
                } catch (error) {
                    console.error(`❌ Strategy ${strategy.name} failed:`, error);
                    updateDebugInfo(url, strategy.name, 'Failed', error.message);
                }
                
                // Wait between strategies for better UX
                if (i < strategies.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }            // All strategies failed - provide comprehensive error message
            const errorMsg = hasMixedContentIssue && !window.securityContext.isDevelopment
                ? `❌ Unable to Play HTTP Stream on HTTPS Site

🔒 Browser Security: This HTTPS site cannot directly play HTTP streams due to Mixed Content security policies.

🌐 Stream URL: ${url}

💡 Reality Check: Most IPTV/streaming services use HTTP-only infrastructure because:
• HTTPS certificates are expensive for streaming providers
• HTTPS adds latency that affects video quality
• Many streaming devices don't support HTTPS
• Legacy infrastructure limitations

🔧 We automatically tried these secure methods:
✗ Vercel proxy server (primary method)
✗ CORS proxy services (backup methods)  
✗ HTTPS upgrade attempt (server doesn't support it)
✗ Multiple proxy networks (may be blocked)

🛠️ Possible solutions:
• Try accessing via HTTP: http://${window.location.host}
• Contact your IPTV provider about HTTPS support
• Use a dedicated IPTV app instead of web browser
• Try from a different network (some ISPs block proxies)

⚠️ This is a common limitation with web-based IPTV players on HTTPS sites.`
                : `❌ Stream Unavailable

Unable to play the stream after trying multiple methods.

🌐 Stream URL: ${url}

🔧 Troubleshooting:
• Check if the stream URL is accessible
• Verify your internet connection  
• Try again in a few minutes
• Contact support if the issue persists

📋 Debug: All playback strategies failed`;
              console.error('All playback strategies failed for:', url);
            updateStatus('error', 'Unable to play stream');
            updateDebugInfo(url, 'All Strategies Failed', 'Error', errorMsg);
            showError(errorMsg);
            channelNameDisplay.textContent = `Failed: ${name}`;
        }

        function tryDirectPlayback(url, name, channelId) {
            return new Promise((resolve, reject) => {
                console.log(`Trying direct playback: ${url}`);
                incrementDebugAttempts();
                updateDebugInfo(url, 'Direct', 'Attempting direct playback');
                
                // Reset and prepare video element
                videoPlayer.src = '';
                videoPlayer.removeAttribute('type');
                videoPlayer.load();
                
                let timeoutId;
                let resolved = false;
                
                const cleanup = () => {
                    if (timeoutId) clearTimeout(timeoutId);
                    videoPlayer.removeEventListener('loadeddata', onSuccess);
                    videoPlayer.removeEventListener('error', onError);
                };
                
                const onSuccess = () => {
                    if (resolved) return;
                    resolved = true;
                    console.log('Direct playback successful');
                    updateStatus('online', `Playing: ${name}`);
                    channelNameDisplay.textContent = `Now Playing: ${name}`;
                    updateDebugInfo(url, 'Direct', 'Success');
                    cleanup();
                    resolve(true);
                };
                
                const onError = (error) => {
                    if (resolved) return;
                    resolved = true;
                    console.error('Direct playback failed:', error);
                    updateDebugInfo(url, 'Direct', 'Failed');
                    cleanup();
                    resolve(false);
                };
                
                // Set up event listeners
                videoPlayer.addEventListener('loadeddata', onSuccess, { once: true });
                videoPlayer.addEventListener('error', onError, { once: true });
                
                // Set source and load
                videoPlayer.src = url;
                videoPlayer.load();
                
                // Timeout after 10 seconds
                timeoutId = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        console.log('Direct playback timeout');
                        cleanup();
                        resolve(false);
                    }
                }, 10000);
            });
        }

        function convertXtremeCodesUrl(url) {
            // Handle Xtreme Codes .ts URLs by converting to M3U8 playlist
            if (url.includes('.ts') && !url.includes('.m3u8')) {
                console.log(`Detected .ts URL, attempting conversion: ${url}`);
                
                // Check if this looks like an Xtreme Codes stream URL
                // Format: http://server:port/username/password/streamid.ts
                const tsRegex = /^(https?:\/\/[^\/]+\/[^\/]+\/[^\/]+\/)(\d+)\.ts$/;
                const match = url.match(tsRegex);
                
                if (match) {
                    // Convert to M3U8 URL: http://server:port/username/password/streamid.m3u8
                    const m3u8Url = match[1] + match[2] + '.m3u8';
                    console.log(`Converting Xtreme Codes .ts URL to M3U8: ${url} -> ${m3u8Url}`);
                    return m3u8Url;
                }
                
                // Alternative format check: look for numeric stream ID at the end
                const altRegex = /^(.+\/)(\d+)\.ts$/;
                const altMatch = url.match(altRegex);
                
                if (altMatch) {
                    const m3u8Url = altMatch[1] + altMatch[2] + '.m3u8';
                    console.log(`Converting alternative .ts URL to M3U8: ${url} -> ${m3u8Url}`);
                    return m3u8Url;
                }
                
                console.log(`Could not convert .ts URL to M3U8 format: ${url}`);
                
                // If conversion fails, still try to play with enhanced headers
                // Some Xtreme Codes servers may serve direct TS streams
                console.log('Will attempt to play .ts stream directly with enhanced compatibility');
            }
            
            return url; // Return original URL if no conversion needed
        }        function tryHlsPlayback(url, name, channelId) {
            return new Promise((resolve, reject) => {
                console.log(`Trying HLS.js playback: ${url}`);
                incrementDebugAttempts();
                updateDebugInfo(url, 'HLS.js', 'Attempting HLS.js playback');
                
                if (!Hls.isSupported()) {
                    console.log('HLS.js not supported');
                    resolve(false);
                    return;
                }

                // Destroy existing HLS instance
                if (hls) {
                    hls.destroy();
                }

                // Create new HLS instance with enhanced configuration
                hls = new Hls({
                    debug: false,
                    enableWorker: true,
                    lowLatencyMode: false, // Disable for better cloud compatibility
                    backBufferLength: 20, // Reduced for cloud environments
                    maxBufferLength: 30, // Prevent excessive buffering
                    maxBufferSize: 60 * 1000 * 1000, // 60MB max buffer
                    fragLoadingMaxRetry: 6, // Increased retries for cloud
                    manifestLoadingMaxRetry: 6,
                    levelLoadingMaxRetry: 6,
                    fragLoadingTimeOut: 25000, // Increased timeout for cloud latency
                    manifestLoadingTimeOut: 15000,
                    levelLoadingTimeOut: 15000,
                    fragLoadingRetryDelay: 1000, // Delay between retries                    manifestLoadingRetryDelay: 1000,
                    // Enhanced for Vercel/cloud deployment
                    xhrSetup: function(xhr, url) {
                        // Set basic headers for better compatibility
                        xhr.withCredentials = false;
                        xhr.timeout = 25000; // 25 second timeout
                        // Remove problematic headers that cause CORS issues
                    },                    fetchSetup: function(context, initParams) {
                        // Enhanced fetch setup for better cloud compatibility
                        const controller = new AbortController();
                        setTimeout(() => controller.abort(), 25000); // 25s timeout
                        
                        return new Request(context.url, {
                            ...initParams,
                            cache: 'no-store',
                            mode: 'cors',
                            credentials: 'omit',
                            signal: controller.signal,
                            headers: {
                                ...initParams.headers
                                // Remove problematic headers that cause CORS issues
                            }
                        });
                    }
                });

                let resolved = false;
                const timeoutId = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        console.log('HLS.js timeout');
                        if (hls) hls.destroy();
                        resolve(false);
                    }
                }, 15000);

                hls.loadSource(url);
                hls.attachMedia(videoPlayer);
                  hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('HLS manifest parsed successfully');
                    videoPlayer.play().then(() => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            updateStatus('online', `Playing: ${name}`);
                            channelNameDisplay.textContent = `Now Playing: ${name}`;
                            updateDebugInfo(url, 'HLS.js', 'Success');
                            applyQualitySettings();
                            hideError(); // Hide any previous errors on successful playback
                            resolve(true);
                        }
                    }).catch(err => {
                        console.error('HLS play promise rejected:', err);
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            if (hls) hls.destroy();
                            resolve(false);
                        }
                    });
                });
                
                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('HLS Error:', event, data);
                    
                    if (data.fatal) {
                        console.error('Fatal HLS error detected:', data.type, data.details);
                        
                        switch(data.type) {
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log('Fatal media error encountered, attempting recovery...');
                                showError('Media playback error - attempting recovery...');
                                
                                // Store the HLS instance globally for potential media recovery
                                window.hls = hls;
                                
                                try {
                                    hls.recoverMediaError();
                                    console.log('Media error recovery initiated');
                                    // Don't resolve immediately, wait for recovery result
                                    return;
                                } catch (recoveryError) {
                                    console.error('Media error recovery failed:', recoveryError);
                                    // Fall through to cleanup and reject
                                }
                                break;
                                
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error('Fatal network error encountered:', data);
                                showError(`Network error: ${data.details || 'Connection failed'}`);
                                
                                // For network errors, we could retry with different config
                                // or attempt proxy fallback, but for now just fail
                                updateDebugInfo(url, 'HLS.js', `Network Error: ${data.details}`);
                                break;
                                
                            default:
                                console.error('Unrecoverable HLS error:', data);
                                showError(`Playback error: ${data.details || 'Unknown error'}`);
                                updateDebugInfo(url, 'HLS.js', `Fatal Error: ${data.type}`);
                                break;
                        }
                        
                        // Clean up and reject if recovery not attempted or failed
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            
                            try {
                                hls.destroy();
                            } catch (destroyError) {
                                console.warn('Error destroying HLS instance:', destroyError);
                            }
                            
                            resolve(false);
                        }
                    } else {
                        // Non-fatal errors - log but continue
                        console.warn('Non-fatal HLS error:', data.type, data.details);
                        
                        // Handle specific non-fatal errors
                        switch(data.details) {
                            case Hls.ErrorDetails.FRAG_LOAD_ERROR:
                                console.log('Fragment load error - HLS.js will retry automatically');
                                break;
                            case Hls.ErrorDetails.BUFFER_STALLED_ERROR:
                                console.log('Buffer stalled - attempting to nudge playback');
                                break;
                            default:
                                console.log('Other non-fatal error:', data.details);                        }
                    }
                });
                
                // Add event listener for successful media recovery
                hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                    console.log('HLS media reattached after recovery');
                });
                
                hls.on(Hls.Events.FRAG_LOADED, () => {
                    // If we had a previous media error and now fragments are loading, recovery likely succeeded
                    if (window.hls === hls && !resolved) {
                        console.log('Fragment loaded after recovery - playback likely restored');
                        hideError();
                        updateStatus('online', `Playing: ${name}`);
                    }
                });
            });
        }function tryNativeHlsPlayback(url, name, channelId) {
            return new Promise((resolve, reject) => {
                console.log(`Trying native HLS playback: ${url}`);
                incrementDebugAttempts();
                updateDebugInfo(url, 'Native HLS', 'Attempting native HLS playback');
                
                // Reset video element
                videoPlayer.src = '';
                videoPlayer.removeAttribute('type');
                videoPlayer.load();
                
                let resolved = false;
                const timeoutId = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        console.log('Native HLS timeout');
                        updateDebugInfo(url, 'Native HLS', 'Timeout');
                        resolve(false);
                    }
                }, 10000);
                
                const cleanup = () => {
                    clearTimeout(timeoutId);
                    videoPlayer.removeEventListener('loadeddata', onSuccess);
                    videoPlayer.removeEventListener('error', onError);
                };
                
                const onSuccess = () => {
                    if (!resolved) {
                        resolved = true;
                        console.log('Native HLS playback successful');
                        updateStatus('online', `Playing: ${name}`);
                        channelNameDisplay.textContent = `Now Playing: ${name}`;
                        updateDebugInfo(url, 'Native HLS', 'Success');
                        cleanup();
                        resolve(true);
                    }
                };
                
                const onError = (error) => {
                    if (!resolved) {
                        resolved = true;
                        console.error('Native HLS playback failed:', error);
                        updateDebugInfo(url, 'Native HLS', 'Failed');
                        cleanup();
                        resolve(false);
                    }
                };
                
                // Set up event listeners
                videoPlayer.addEventListener('loadeddata', onSuccess, { once: true });
                videoPlayer.addEventListener('error', onError, { once: true });
                
                // Set source with HLS MIME type
                videoPlayer.src = url;
                videoPlayer.setAttribute('type', 'application/vnd.apple.mpegurl');
                videoPlayer.load();
            });
        }

        function tryAlternativeFormats(url, name, channelId) {
            console.log(`Trying alternative formats for: ${url}`);
            
            // Create a temporary video element to test format support
            const testVideo = document.createElement('video');
            
            // Test different MIME types
            const formats = [
                'video/mp4',
                'application/vnd.apple.mpegurl',
                'application/x-mpegURL',
                'video/MP2T',
                'application/octet-stream'
            ];
            
            for (const format of formats) {
                if (testVideo.canPlayType(format) !== '') {
                    console.log(`Trying format: ${format}`);
                    videoPlayer.src = url;
                    videoPlayer.setAttribute('type', format);
                    videoPlayer.load();
                    
                    const playPromise = videoPlayer.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log(`Format ${format} playback successful`);
                            updateStatus('online', `Playing: ${name}`);
                            channelNameDisplay.textContent = `Now Playing: ${name}`;
                            return; // Success, exit function
                        }).catch(err => {
                            console.error(`Format ${format} failed:`, err);
                        });
                    }
                }
            }
            
            // If all formats failed, try proxied playback
            setTimeout(() => tryProxiedPlayback(url, name, channelId), 2000);
        }        function tryDirectPlayback(url, name, channelId) {
            console.log(`Trying direct playback: ${url}`);
            incrementDebugAttempts();
            updateDebugInfo(url, 'Direct', 'Attempting direct playback');
            
            // Reset and prepare video element
            videoPlayer.src = '';
            videoPlayer.removeAttribute('type');
            videoPlayer.load();
            
            // Set source with proper error handling
            videoPlayer.src = url;
            videoPlayer.load();
            
            // Add a one-time load event listener
            const onLoadedData = () => {
                console.log('Video loaded data successfully');
                videoPlayer.removeEventListener('loadeddata', onLoadedData);
                videoPlayer.removeEventListener('error', onError);
                
                const playPromise = videoPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('Direct playback successful');
                        updateStatus('online', `Playing: ${name}`);
                        channelNameDisplay.textContent = `Now Playing: ${name}`;
                        updateDebugInfo('', '', 'Playing successfully');
                    }).catch(err => {
                        console.error('Direct play promise rejected:', err);
                        updateDebugInfo('', '', 'Play promise rejected', err.message);
                        // Try format detection
                        tryWithHeaders(url, name, channelId);
                    });
                }
            };
            
            const onError = (e) => {
                console.error('Direct playback error:', e);
                videoPlayer.removeEventListener('loadeddata', onLoadedData);
                videoPlayer.removeEventListener('error', onError);
                
                const errorMsg = e.target?.error ? `Media error code ${e.target.error.code}` : 'Load failed';
                updateDebugInfo('', '', 'Direct failed', errorMsg);
                // Try with custom headers via proxy
                tryWithHeaders(url, name, channelId);
            };
            
            videoPlayer.addEventListener('loadeddata', onLoadedData, { once: true });
            videoPlayer.addEventListener('error', onError, { once: true });
            
            // Set a timeout for loading
            setTimeout(() => {
                if (videoPlayer.readyState === 0) {
                    console.log('Direct playback timeout, trying alternatives...');
                    videoPlayer.removeEventListener('loadeddata', onLoadedData);
                    videoPlayer.removeEventListener('error', onError);
                    updateDebugInfo('', '', 'Direct timeout', 'Load timeout after 10s');
                    tryWithHeaders(url, name, channelId);
                }
            }, 10000); // 10 second timeout
        }

        function tryWithHeaders(url, name, channelId) {
            console.log(`Trying playback with custom headers: ${url}`);            // For streams that might need specific headers, try a workaround
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = `data:text/html,
                <html>
                    <head>
                        <meta name="referrer" content="no-referrer">
                    </head>
                    <body style="margin:0;padding:0;">
                        <video controls autoplay style="width:100%;height:100vh;">
                            <source src="${url}" type="application/vnd.apple.mpegurl">
                            <source src="${url}" type="video/mp4">
                            <source src="${url}" type="application/x-mpegURL">
                            <source src="${url}">
                            Your browser does not support this video format.
                        </video>
                    </body>
                </html>`;
            
            document.body.appendChild(iframe);
            
            setTimeout(() => {
                document.body.removeChild(iframe);
                // If iframe approach doesn't work, try proxied
                tryProxiedPlayback(url, name, channelId);
            }, 3000);
              // Meanwhile, also try proxied immediately
            setTimeout(() => tryProxiedPlayback(url, name, channelId), 1000);
        }
          function tryProxiedPlayback(url, name, channelId) {
            return new Promise((resolve) => {
                console.log(`Trying proxied playback: ${url}`);
                incrementDebugAttempts();
                updateDebugInfo(url, 'Proxy', 'Attempting proxy playback');
                
                // Try each proxy in sequence
                let proxyIndex = 0;
                let attempts = 0;
                const maxAttempts = PROXIES.length * 2; // Try each proxy twice
                let resolved = false;
                
                const tryNextProxy = () => {
                    if (resolved) return;
                    
                    if (attempts >= maxAttempts) {
                        const finalError = `All playback methods failed for "${name}". 
                        
Possible causes:
• Stream is offline or temporarily unavailable
• Stream format not supported by browser  
• Geographic restrictions (try VPN)
• Server blocking requests

Stream URL: ${url}`;
                        showError(finalError);
                        updateStatus('error', 'Playback failed');
                        updateDebugInfo('', '', 'All methods failed', 'Exhausted all proxies and methods');
                        
                        if (!resolved) {
                            resolved = true;
                            resolve(false);
                        }
                        return;
                    }

                    const proxy = PROXIES[proxyIndex % PROXIES.length];
                    let proxiedUrl;
                    
                    // Handle different proxy formats
                    if (proxy.includes('allorigins.win')) {
                        proxiedUrl = `${proxy}${encodeURIComponent(url)}`;
                    } else if (proxy.includes('cors.eu.org')) {
                        proxiedUrl = `${proxy}${url}`;
                    } else if (proxy.includes('codetabs.com')) {
                        proxiedUrl = `${proxy}${encodeURIComponent(url)}`;
                    } else {
                        proxiedUrl = `${proxy}${encodeURIComponent(url)}`;
                    }
                    
                    console.log(`Trying proxy ${proxyIndex + 1} (attempt ${attempts + 1}): ${proxy}`);
                    updateStatus('loading', `Trying proxy server ${proxyIndex + 1}/${PROXIES.length}...`);
                    updateDebugInfo(proxiedUrl, `Proxy ${proxyIndex + 1}`, `Attempt ${attempts + 1}/${maxAttempts}`);
                    
                    // For HLS streams, try HLS.js with proxy first
                    if (url.includes('.m3u8') || url.includes('playlist')) {
                        tryProxiedHlsPlayback(proxiedUrl, name, channelId)
                            .then(success => {
                                if (success && !resolved) {
                                    resolved = true;
                                    resolve(true);
                                } else if (!resolved) {
                                    // Fall back to direct video element approach
                                    tryProxiedDirectPlayback(proxiedUrl, name, channelId, onProxyResult);
                                }
                            })
                            .catch(() => {
                                if (!resolved) {
                                    // Fall back to direct video element approach
                                    tryProxiedDirectPlayback(proxiedUrl, name, channelId, onProxyResult);
                                }
                            });
                    } else {
                        // For non-HLS streams, try direct playback through proxy
                        tryProxiedDirectPlayback(proxiedUrl, name, channelId, onProxyResult);
                    }
                    
                    
                    function onProxyResult(success, error) {
                        if (resolved) return;
                        
                        if (success) {
                            console.log(`Proxied playback successful with proxy ${proxyIndex + 1}`);
                            updateStatus('online', `Playing: ${name} (via proxy)`);
                            channelNameDisplay.textContent = `Now Playing: ${name}`;
                            updateDebugInfo('', '', 'Playing via proxy successfully');
                            
                            resolved = true;
                            return;
                        } else {
                            console.warn(`Proxied playback failed with proxy ${proxyIndex + 1}:`, error);
                        }
                        
                        // Try next proxy
                        proxyIndex++;
                        attempts++;
                        setTimeout(tryNextProxy, 1000); // Wait before trying next proxy
                    }
                };
                
                tryNextProxy();
            });
        }
        
        function tryProxiedHlsPlayback(proxiedUrl, name, channelId) {
            return new Promise((resolve) => {
                console.log(`Trying HLS.js with proxied URL: ${proxiedUrl}`);
                
                if (!window.Hls || !Hls.isSupported()) {
                    console.log('HLS.js not supported for proxy playback');
                    resolve(false);
                    return;
                }
                
                const hlsInstance = new Hls({
                    debug: false,
                    enableWorker: true,
                                       maxBufferLength: 20,
                    fragLoadingMaxRetry: 3, // Reduced retries for proxied streams
                    manifestLoadingMaxRetry: 3,
                    fragLoadingTimeOut: 20000,
                    manifestLoadingTimeOut: 15000,
                    xhrSetup: function(xhr, url) {
                        xhr.withCredentials = false;
                        xhr.timeout = 20000;
                    }
                });
                
                let resolved = false;
                const timeoutId = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        try {
                            hlsInstance.destroy();
                        } catch (e) {}
                        resolve(false);
                    }
                }, 15000);
                
                hlsInstance.loadSource(proxiedUrl);
                hlsInstance.attachMedia(videoPlayer);
                
                hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
                    videoPlayer.play().then(() => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            console.log('Proxied HLS playback successful');
                            window.hls = hlsInstance; // Store for error recovery
                            resolve(true);
                        }
                    }).catch(() => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            try {
                                hlsInstance.destroy();
                            } catch (e) {}
                            resolve(false);
                        }
                    });
                });
                
                hlsInstance.on(Hls.Events.ERROR, (event, data) => {
                    if (data.fatal && !resolved) {
                        resolved = true;
                        clearTimeout(timeoutId);
                        try {
                            hlsInstance.destroy();
                        } catch (e) {}
                        resolve(false);
                    }
                });
            });
        }
        
        function tryProxiedDirectPlayback(proxiedUrl, name, channelId, callback) {
            console.log(`Trying direct playback with proxied URL: ${proxiedUrl}`);
            
            // Reset video element
            videoPlayer.src = '';
            videoPlayer.removeAttribute('type');
            videoPlayer.load();
            
            // Set proxied source
            videoPlayer.src = proxiedUrl;
            videoPlayer.load();
            
            let callbackCalled = false;
            
            const cleanup = () => {
                videoPlayer.removeEventListener('loadeddata', onLoadedData);
                videoPlayer.removeEventListener('canplay', onCanPlay);
                videoPlayer.removeEventListener('error', onVideoError);
            };
            
            const onSuccess = () => {
                if (!callbackCalled) {
                    callbackCalled = true;
                    cleanup();
                    callback(true);
                }
            };
            
            const onError = (error) => {
                if (!callbackCalled) {
                    callbackCalled = true;
                    cleanup();
                    callback(false, error);
                }
            };
            
            const onLoadedData = () => {
                const playPromise = videoPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(onSuccess).catch(onError);
                } else {
                    onSuccess();
                }
            };
            
            const onCanPlay = () => {
                const playPromise = videoPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(onSuccess).catch(onError);
                } else {
                    onSuccess();
                }
            };
            
            const onVideoError = (e) => {
                console.error('Video element error with proxy:', e);
                onError(e);
            };
            
            videoPlayer.addEventListener('loadeddata', onLoadedData, { once: true });
            videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
            videoPlayer.addEventListener('error', onVideoError, { once: true });
              // Timeout for this attempt
            setTimeout(() => {
                if (!callbackCalled && videoPlayer.readyState === 0) {
                    console.log(`Proxied direct playback timeout`);
                    onError(new Error('Timeout - stream may be slow or blocked'));
                }
            }, 15000); // 15 second timeout per proxy
        }

        function tryBlobPlayback(url, name, channelId) {
            console.log(`Trying blob playback as final fallback: ${url}`);
            updateStatus('loading', 'Trying final fallback method...');            // This is a last-resort attempt using fetch and blob
            fetch(url, {
                mode: 'cors',
                credentials: 'omit'
            }).then(response => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return response.blob();
            }).then(blob => {
                const blobUrl = URL.createObjectURL(blob);
                videoPlayer.src = blobUrl;
                
                const playPromise = videoPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('Blob playback successful');
                        updateStatus('online', `Playing: ${name} (cached)`);
                        channelNameDisplay.textContent = `Now Playing: ${name}`;
                        
                        // Clean up blob URL when done
                        videoPlayer.addEventListener('ended', () => URL.revokeObjectURL(blobUrl), { once: true });
                    }).catch(err => {
                        console.error('Blob playback failed:', err);
                        URL.revokeObjectURL(blobUrl);
                        showError(`Unable to play "${name}". This stream may require special browser extensions or is not compatible with web players.
                        
Stream URL: ${url}
                        
Try:
• Refreshing the page
• Using a different browser
• Installing browser extensions for streaming
• Checking if the stream works in a media player like VLC`);
                        updateStatus('error', 'All methods failed');
                    });
                }            }).catch(err => {
                console.error('Blob fetch failed:', err);
                
                // Provide specific guidance for different stream types
                let errorMessage = `Unable to play "${name}". All playback methods exhausted.`;
                
                if (url.includes('.ts')) {
                    errorMessage += `

🔍 XTREME CODES / .TS STREAM DETECTED
This appears to be an Xtreme Codes stream. Common issues:

• Server may be down or overloaded
• Credentials may be expired or invalid
• Stream may require direct IPTV player (VLC, Kodi, etc.)
• Geographic restrictions may apply
• .ts segments may need to be accessed via M3U8 playlist

💡 TROUBLESHOOTING:
• Verify your Xtreme Codes credentials are current
• Try playing the stream in VLC or another IPTV player
• Check if the provider offers M3U8 URLs instead of .ts
• Contact your IPTV provider for assistance`;
                } else {
                    errorMessage += `

This could be due to:
• Stream is offline or geographically restricted
• Requires authentication or special headers
• Stream format not supported by web browsers
• Network connectivity issues`;
                }
                
                errorMessage += `

Stream URL: ${url}`;
                
                showError(errorMessage);
                updateStatus('error', 'Stream incompatible');
            });
        }

        // --- MISSING UTILITY FUNCTIONS ---
        
        /**
         * Validates a stream URL and ensures it uses HTTP/HTTPS protocol
         * @param {string} url - The URL to validate
         * @returns {string} - The validated and cleaned URL
         * @throws {Error} - If the URL is invalid or uses unsupported protocol
         */
        function validateUrl(url) {
            if (!url || typeof url !== 'string') {
                throw new Error('Invalid URL: URL must be a non-empty string');
            }
            
            // Remove any leading/trailing whitespace
            const cleanUrl = url.trim();
            
            if (!cleanUrl) {
                throw new Error('Invalid URL: URL cannot be empty');
            }
            
            try {
                const urlObj = new URL(cleanUrl);
                
                // Check if protocol is supported
                if (!['http:', 'https:'].includes(urlObj.protocol)) {
                    throw new Error(`Unsupported protocol: ${urlObj.protocol}. Only HTTP and HTTPS URLs are supported.`);
                }
                
                return cleanUrl;
            } catch (error) {
                if (error.message.includes('Unsupported protocol')) {
                    throw error;
                }
                throw new Error(`Invalid URL format: ${cleanUrl}. Please ensure the URL is properly formatted (e.g., http://example.com/stream.m3u8)`);
            }
        }        /**
         * Attempts to upgrade an HTTP URL to HTTPS and play the stream
         * @param {string} url - The original HTTP URL
         * @param {string} name - Channel name
         * @param {string} channelId - Channel ID
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */        async function tryHttpsUpgrade(url, name, channelId) {
            console.log('🔒 Attempting HTTPS upgrade for mixed content resolution...');
            
            // Only attempt if URL is HTTP
            if (!url.startsWith('http://')) {
                console.log('URL is not HTTP, skipping HTTPS upgrade');
                return false;
            }
            
            try {
                const httpsUrl = url.replace('http://', 'https://');
                console.log(`🔄 Upgrading URL: ${url} -> ${httpsUrl}`);
                
                updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Testing', 'Checking if HTTPS version exists');
                
                // Test if HTTPS version is accessible with reduced timeout and better error handling
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                
                try {
                    const response = await fetch(httpsUrl, {
                        method: 'HEAD',
                        mode: 'cors',
                        cache: 'no-store',
                        credentials: 'omit',
                        signal: controller.signal,
                        headers: {
                            'Accept': '*/*',
                            'User-Agent': 'Mozilla/5.0 (compatible; IPTV-Player)'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        console.log(`❌ HTTPS upgrade failed: HTTP ${response.status} ${response.statusText}`);
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', `Server returned ${response.status} - HTTPS not supported`);
                        return false;
                    }
                    
                    console.log('✅ HTTPS version is accessible, attempting playback...');
                    updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Success', 'HTTPS version accessible');
                    
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    
                    // Common HTTPS upgrade failure scenarios
                    if (fetchError.name === 'AbortError') {
                        console.log('❌ HTTPS upgrade timeout - server likely doesn\'t support HTTPS');
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'Timeout - HTTPS not supported');
                    } else if (fetchError.message.includes('net::ERR_SSL') || fetchError.message.includes('SSL')) {
                        console.log('❌ HTTPS upgrade failed - SSL/TLS certificate issues');
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'SSL certificate error');
                    } else if (fetchError.message.includes('net::ERR_CONNECTION_REFUSED')) {
                        console.log('❌ HTTPS upgrade failed - server doesn\'t accept HTTPS connections');
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'HTTPS port not available');
                    } else {
                        console.log('❌ HTTPS upgrade failed - general network error:', fetchError.message);
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'Network error - HTTPS not available');
                    }
                    return false;
                }
                
                // Try both direct and HLS playback for HTTPS URL
                if (httpsUrl.includes('.m3u8') || httpsUrl.includes('playlist')) {
                    // Try HLS.js first for M3U8 streams
                    if (Hls.isSupported()) {
                        const hlsSuccess = await new Promise((resolve) => {
                            if (window.hls) {
                                window.hls.destroy();
                            }
                            
                            window.hls = new Hls({
                                enableWorker: true,
                                lowLatencyMode: true,
                                backBufferLength: 90,
                                xhrSetup: function(xhr, url) {
                                    // Minimal headers for HTTPS upgrade
                                    xhr.setRequestHeader('Accept', '*/*');
                                }
                            });
                            
                            const onManifestParsed = () => {
                                console.log('✅ HTTPS upgrade HLS manifest loaded successfully');
                                videoPlayer.play().then(() => {
                                    updateStatus('online', `Playing: ${name} (HTTPS)`);
                                    channelNameDisplay.textContent = `Now Playing: ${name}`;
                                    updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Success', 'HLS playback started');
                                    cleanup();
                                    resolve(true);
                                }).catch((error) => {
                                    console.log('❌ HTTPS upgrade HLS playback failed:', error);
                                    cleanup();
                                    resolve(false);
                                });
                            };
                            
                            const onError = (event, data) => {
                                console.log('❌ HTTPS upgrade HLS error:', data);
                                updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', `HLS error: ${data.type}`);
                                cleanup();
                                resolve(false);
                            };
                            
                            const cleanup = () => {
                                window.hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                window.hls.off(Hls.Events.ERROR, onError);
                            };
                            
                            window.hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                            window.hls.on(Hls.Events.ERROR, onError);
                            window.hls.loadSource(httpsUrl);
                            window.hls.attachMedia(videoPlayer);
                            
                            // Timeout after 15 seconds
                            setTimeout(() => {
                                cleanup();
                                if (window.hls) {
                                    window.hls.destroy();
                                    window.hls = null;
                                }
                                resolve(false);
                            }, 15000);
                        });
                        
                        if (hlsSuccess) {
                            return true;
                        }
                    }
                }
                
                // Try direct playback with HTTPS URL
                return new Promise((resolve) => {
                    videoPlayer.src = httpsUrl;
                    
                    const onCanPlay = () => {
                        console.log('✅ HTTPS upgrade direct playback successful');
                        updateStatus('online', `Playing: ${name} (HTTPS)`);
                        channelNameDisplay.textContent = `Now Playing: ${name}`;
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Success', 'Direct playback started');
                        cleanup();
                        resolve(true);
                    };
                    
                    const onError = (error) => {
                        console.log('❌ HTTPS upgrade direct playback failed:', error);
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'Direct playback error');
                        cleanup();
                        resolve(false);
                    };
                    
                    const cleanup = () => {
                        videoPlayer.removeEventListener('canplay', onCanPlay);
                        videoPlayer.removeEventListener('error', onError);
                    };
                    
                    videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
                    videoPlayer.addEventListener('error', onError, { once: true });
                    
                    // Timeout after 15 seconds
                    setTimeout(() => {
                        cleanup();
                        resolve(false);
                    }, 15000);
                });
                
            } catch (error) {
                console.log('❌ HTTPS upgrade failed:', error.message);
                updateDebugInfo(httpsUrl || url, 'HTTPS Upgrade', 'Failed', `Network error: ${error.message}`);
                return false;
            }        }

        /**
         * Attempts to play a stream through a server proxy
         * @param {string} url - The stream URL
         * @param {string} name - Channel name
         * @param {string} channelId - Channel ID
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */        async function tryServerProxy(url, name, channelId) {
            console.log('🔄 Attempting server proxy playback for HTTP stream on HTTPS page...');
            
            try {
                // Use our API proxy endpoint if available
                const proxyUrl = `/api/proxy?url=${encodeURIComponent(url)}`;
                
                updateDebugInfo(proxyUrl, 'Server Proxy', 'Testing', 'Using Vercel serverless proxy to bypass mixed content');
                
                // Test proxy availability first with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                
                try {
                    const testResponse = await fetch(proxyUrl, {
                        method: 'HEAD',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!testResponse.ok) {
                        if (testResponse.status === 502 || testResponse.status === 503) {
                            console.log(`❌ Server proxy failed: Streaming server unreachable (${testResponse.status})`);
                            updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', 'Streaming server unreachable - common with HTTP-only IPTV servers');
                        } else {
                            console.log(`❌ Server proxy failed: HTTP ${testResponse.status}`);
                            updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', `Proxy error ${testResponse.status}`);
                        }
                        return false;
                    }
                    
                    console.log('✅ Server proxy accessible, attempting stream playback...');
                    updateDebugInfo(proxyUrl, 'Server Proxy', 'Success', 'Proxy responding, trying playback');
                    
                } catch (proxyError) {
                    clearTimeout(timeoutId);
                    
                    if (proxyError.name === 'AbortError') {
                        console.log('❌ Server proxy timeout - streaming server likely slow or unreachable');
                        updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', 'Timeout - streaming server too slow');
                    } else {
                        console.log('❌ Server proxy network error:', proxyError.message);
                        updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', 'Network error reaching streaming server');
                    }
                    return false;
                }
                
                // Check if it's an HLS stream
                if (url.includes('.m3u8') || url.includes('playlist')) {
                    // Use HLS.js for M3U8 streams through proxy
                    if (Hls.isSupported()) {
                        return new Promise((resolve) => {
                            if (window.hls) {
                                window.hls.destroy();
                            }
                            
                            window.hls = new Hls({
                                enableWorker: true,
                                lowLatencyMode: true,
                                backBufferLength: 90
                            });
                            
                            const onManifestParsed = () => {
                                console.log('Server proxy HLS manifest loaded successfully');
                                videoPlayer.play().then(() => {
                                    updateStatus('online', `Playing: ${name} (Server Proxy)`);
                                    channelNameDisplay.textContent = `Now Playing: ${name}`;
                                    cleanup();
                                    resolve(true);
                                }).catch((error) => {
                                    console.log('Server proxy HLS playback failed:', error);
                                    cleanup();
                                    resolve(false);
                                });
                            };
                            
                            const onError = (event, data) => {
                                console.log('Server proxy HLS error:', data);
                                cleanup();
                                resolve(false);
                            };
                            
                            const cleanup = () => {
                                window.hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                window.hls.off(Hls.Events.ERROR, onError);
                            };
                            
                            window.hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                            window.hls.on(Hls.Events.ERROR, onError);
                            window.hls.loadSource(proxyUrl);
                            window.hls.attachMedia(videoPlayer);
                            
                            // Timeout after 20 seconds
                            setTimeout(() => {
                                cleanup();
                                if (window.hls) {
                                    window.hls.destroy();
                                    window.hls = null;
                                }
                                resolve(false);
                            }, 20000);
                        });
                    }
                } else {
                    // Direct proxy playback for non-HLS streams
                    videoPlayer.src = proxyUrl;
                    
                    return new Promise((resolve) => {
                        const onCanPlay = () => {
                            console.log('Server proxy direct playback successful');
                            updateStatus('online', `Playing: ${name} (Server Proxy)`);
                            channelNameDisplay.textContent = `Now Playing: ${name}`;
                            cleanup();
                            resolve(true);
                        };
                        
                        const onError = (error) => {
                            console.log('Server proxy direct playback failed:', error);
                            cleanup();
                            resolve(false);
                        };
                        
                        const cleanup = () => {
                            videoPlayer.removeEventListener('canplay', onCanPlay);
                            videoPlayer.removeEventListener('error', onError);
                        };
                        
                        videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
                        videoPlayer.addEventListener('error', onError, { once: true });
                        
                        // Timeout after 15 seconds
                        setTimeout(() => {
                            cleanup();
                            resolve(false);
                        }, 15000);
                    });
                }
                
            } catch (error) {
                console.log('Server proxy failed:', error.message);
                updateDebugInfo('', '', 'Failed', `Server proxy error: ${error.message}`);
                return false;
            }
        }

        /**
         * Attempts to play a stream through a secure CORS proxy (HTTPS)
         * @param {string} url - The stream URL
         * @param {string} name - Channel name
         * @param {string} channelId - Channel ID
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */
        async function trySecureProxy(url, name, channelId) {
            console.log('Attempting secure proxy playback...');
            
            // Secure proxies for mixed content scenarios
            const secureProxies = [
                'https://cors-anywhere.herokuapp.com/',
                'https://thingproxy.freeboard.io/fetch/',
                'https://api.allorigins.win/raw?url='
            ];
            
            for (const proxy of secureProxies) {
                try {
                    console.log(`Trying secure proxy: ${proxy}`);
                    const proxyUrl = proxy + encodeURIComponent(url);
                    
                    updateDebugInfo(proxyUrl, 'Secure Proxy', `Testing ${proxy}`);
                    
                    // Test proxy availability first with a HEAD request
                    const testResponse = await fetch(proxyUrl, {
                        method: 'HEAD',
                        mode: 'cors',
                        cache: 'no-store',
                        credentials: 'omit',
                        signal: AbortSignal.timeout(8000)
                    });
                    
                    if (!testResponse.ok) {
                        console.log(`Secure proxy ${proxy} not available: HTTP ${testResponse.status}`);
                        continue;
                    }
                    
                    console.log(`Secure proxy ${proxy} is available, attempting playback...`);
                    
                    // Check if it's an HLS stream
                    if (url.includes('.m3u8') || url.includes('playlist')) {
                        // Use HLS.js for M3U8 streams through secure proxy
                        if (Hls.isSupported()) {
                            const success = await new Promise((resolve) => {
                                if (window.hls) {
                                    window.hls.destroy();
                                }
                                
                                window.hls = new Hls({
                                    enableWorker: true,
                                    lowLatencyMode: true,
                                    backBufferLength: 90,
                                    xhrSetup: function(xhr, url) {
                                        // Minimal headers for secure proxy
                                        xhr.setRequestHeader('Accept', '*/*');
                                    }
                                });
                                
                                const onManifestParsed = () => {
                                    console.log(`Secure proxy ${proxy} HLS manifest loaded`);
                                    videoPlayer.play().then(() => {
                                        updateStatus('online', `Playing: ${name} (Secure Proxy)`);
                                        channelNameDisplay.textContent = `Now Playing: ${name}`;
                                        cleanup();
                                        resolve(true);
                                    }).catch((error) => {
                                        console.log(`Secure proxy ${proxy} HLS playback failed:`, error);
                                        cleanup();
                                        resolve(false);
                                    });
                                };
                                
                                const onError = (event, data) => {
                                    console.log(`Secure proxy ${proxy} HLS error:`, data);
                                    cleanup();
                                    resolve(false);
                                };
                                
                                const cleanup = () => {
                                    window.hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                    window.hls.off(Hls.Events.ERROR, onError);
                                };
                                
                                window.hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                window.hls.on(Hls.Events.ERROR, onError);
                                window.hls.loadSource(proxyUrl);
                                window.hls.attachMedia(videoPlayer);
                                
                                // Timeout after 15 seconds
                                setTimeout(() => {
                                    cleanup();
                                    if (window.hls) {
                                        window.hls.destroy();
                                        window.hls = null;
                                    }
                                    resolve(false);
                                }, 15000);
                            });
                            
                            if (success) {
                                return true;
                            }
                        }
                    } else {                        // Direct proxy playback for non-HLS streams
                        const success = await new Promise((resolve) => {
                            videoPlayer.src = proxyUrl;
                            
                            const onCanPlay = () => {
                                console.log(`Secure proxy ${proxy} direct playback successful`);
                                updateStatus('online', `Playing: ${name} (Secure Proxy)`);
                                channelNameDisplay.textContent = `Now Playing: ${name}`;
                                cleanup();
                                resolve(true);
                            };
                            
                            const onError = (error) => {
                                console.log(`Secure proxy ${proxy} direct playback failed:`, error);
                                cleanup();
                                resolve(false);
                            };
                            
                            const cleanup = () => {
                                videoPlayer.removeEventListener('canplay', onCanPlay);
                                videoPlayer.removeEventListener('error', onError);
                            };
                            
                            videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
                            videoPlayer.addEventListener('error', onError, { once: true });
                              // Timeout after 10 seconds
                            setTimeout(() => {
                                cleanup();
                                resolve(false);
                            }, 10000);
                        });
                        
                        if (success) {
                            return true;
                        }
                    }
                } catch (error) {
                    console.log(`Secure proxy ${proxy} failed:`, error.message);
                    updateDebugInfo('', '', 'Failed', `Secure proxy ${proxy} error: ${error.message}`);
                    // Continue to next proxy
                }
            }

            console.log('All secure proxies failed');
            return false;
        }

        // Initialize the application
        function init() {
            try {
                // Initialize security detection
                if (window.securityContext.isHttps && !window.securityContext.isDevelopment) {
                    console.log('🔒 HTTPS page detected - Mixed Content security active');
                }
                
                console.log('🔍 Security Context:', window.securityContext);
            } catch (error) {
                console.error('Error initializing security context:', error);
            }
        }

        init();
    });
    </script>
</body>
</html>