<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature-Rich M3U Streamer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">    <style>
        body { font-family: 'Inter', sans-serif; }
        #channel-list-container {
            scrollbar-width: thin;
            scrollbar-color: #4a5568 #1a202c;
        }
        #channel-list-container::-webkit-scrollbar { width: 8px; }
        #channel-list-container::-webkit-scrollbar-track { background: #1a202c; }
        #channel-list-container::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 4px; }
        .channel-item.active { background-color: #2b6cb0; box-shadow: 0 0 0 2px #60a5fa; }
        .favorite-star.favorited { color: #f6e05e; /* yellow-400 */ }
        .loader { border-top-color: #3498db; }
        
        /* Enhanced visual feedback */
        .channel-item:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .channel-item { transition: all 0.2s ease; }
        
        /* Fullscreen button styling */
        .control-btn { 
            background: rgba(0,0,0,0.6); 
            backdrop-filter: blur(4px);
            transition: all 0.2s ease;
        }
        .control-btn:hover { background: rgba(0,0,0,0.8); transform: scale(1.05); }
        
        /* Better loading animation */
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .loading-text { animation: pulse 1.5s ease-in-out infinite; }
        
        /* Mobile improvements */
        @media (max-width: 768px) {
            #channel-list { grid-template-columns: 1fr !important; }
            .channel-item { padding: 16px !important; }
        }
        
        /* Status indicators */
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-online { background-color: #10b981; }
        .status-loading { background-color: #f59e0b; animation: pulse 1s infinite; }
        .status-error { background-color: #ef4444; }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col">    <!-- Video Player Section -->
    <div class="w-full bg-black flex-shrink-0 relative group">
        <video id="video-player" class="w-full h-full max-h-[50vh]" controls preload="metadata"></video>
        <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2">
            <button id="fullscreen-btn" title="Fullscreen (F)" class="control-btn text-white p-2 rounded-full hover:bg-opacity-75">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/>
                </svg>
            </button>
            <button id="pip-btn" title="Picture-in-Picture (P)" class="control-btn text-white p-2 rounded-full hover:bg-opacity-75">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M0 3.5A1.5 1.5 0 0 1 1.5 2h13A1.5 1.5 0 0 1 16 3.5v9A1.5 1.5 0 0 1 14.5 14h-13A1.5 1.5 0 0 1 0 12.5v-9zM1.5 3a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-13z"/>
                    <path d="M8 8.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5v-3z"/>
                </svg>
            </button>
        </div>
        <div id="current-channel" class="text-center py-2 text-base font-semibold bg-gray-800 flex items-center justify-center">
            <span id="status-indicator" class="status-indicator mr-2" style="display: none;"></span>
            <span id="channel-name">Select a channel to start playing</span>
        </div>
    </div>    <!-- Controls Section -->
    <div class="flex-shrink-0 p-3 bg-gray-800 border-t border-gray-700 space-y-3">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
            <button id="manage-playlists-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2" viewBox="0 0 16 16">
                    <path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/>
                </svg>
                Manage Playlists
            </button>
            <select id="playlist-select" class="bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            <input id="epg-url" type="text" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter EPG XMLTV URL (optional)">
            <button id="load-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2" viewBox="0 0 16 16">
                    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                    <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
                </svg>
                Load Playlist
            </button>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
            <input id="search-input" type="text" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Search channels... (Ctrl+F)">
            <select id="group-filter" class="bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
            <select id="quality-select" class="bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="auto">Auto Quality</option>
                <option value="high">High Quality</option>
                <option value="medium">Medium Quality</option>
                <option value="low">Low Quality</option>
            </select>
        </div>        <div class="text-xs text-gray-400 text-center flex items-center justify-between">
            <span>Shortcuts: Space (Play/Pause) • ↑↓ (Volume) • ←→ (Seek) • F (Fullscreen) • P (PiP) • Ctrl+F (Search)</span>
            <button id="debug-toggle" class="ml-4 bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white px-2 py-1 rounded text-xs transition-colors" title="Show debug info">
                Debug
            </button>
        </div>
    </div>    
    <div id="error-message" class="text-red-400 text-sm p-3 bg-red-900 border-l-4 border-red-500 hidden flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2 flex-shrink-0" viewBox="0 0 16 16">
            <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/>
        </svg>
        <span id="error-text"></span>
        <button id="close-error" class="ml-auto text-red-300 hover:text-red-100">×</button>
    </div>

    <!-- Success Message -->
    <div id="success-message" class="text-green-400 text-sm p-3 bg-green-900 border-l-4 border-green-500 hidden flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2 flex-shrink-0" viewBox="0 0 16 16">
            <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
            <path d="M10.97 4.97a.235.235 0 0 0-.02.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.061L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-1.071-1.05z"/>
        </svg>
        <span id="success-text"></span>
        <button id="close-success" class="ml-auto text-green-300 hover:text-green-100">×</button>
    </div>    <!-- Channel List -->
    <main id="channel-list-container" class="flex-grow overflow-y-auto p-3">
        <div id="channel-list" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3">
            <p class="text-gray-400 col-span-full text-center">Manage and load a playlist to get started.</p>
        </div>
    </main>

    <!-- Debug Panel -->
    <div id="debug-panel" class="fixed bottom-4 right-4 bg-gray-800 border border-gray-600 rounded-lg p-4 max-w-md hidden z-30">
        <div class="flex items-center justify-between mb-3">
            <h3 class="text-white font-semibold">Stream Debug Info</h3>
            <button id="close-debug" class="text-gray-400 hover:text-white">×</button>
        </div>
        <div id="debug-content" class="text-sm text-gray-300 space-y-2">
            <div><strong>Stream URL:</strong> <span id="debug-url" class="break-all">-</span></div>
            <div><strong>Method:</strong> <span id="debug-method">-</span></div>
            <div><strong>Status:</strong> <span id="debug-status">-</span></div>
            <div><strong>Browser Support:</strong> <span id="debug-support">-</span></div>
            <div><strong>Attempts:</strong> <span id="debug-attempts">-</span></div>
            <div><strong>Last Error:</strong> <span id="debug-error" class="text-red-400">-</span></div>
        </div>
        <div class="mt-3 space-x-2">
            <button id="debug-copy" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-xs">Copy Info</button>
            <button id="debug-test" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-xs">Test Stream</button>
        </div>
    </div><!-- Loading Spinner -->
    <div id="loader-overlay" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center hidden z-50">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24 animate-spin mb-4"></div>
        <div id="loading-title" class="text-white text-lg font-semibold loading-text mb-2">Loading playlist...</div>
        <div id="loading-progress" class="text-blue-400 text-base font-medium mb-2"></div>
        <div id="loading-details" class="text-gray-400 text-sm text-center max-w-md">
            Please wait while we fetch your channels
        </div>
        <div id="loading-stats" class="text-gray-500 text-xs mt-4 text-center"></div>
        
        <!-- Progress Bar -->
        <div class="w-80 bg-gray-700 rounded-full h-2 mt-4 hidden" id="progress-bar-container">
            <div id="progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
    </div>

    <!-- Playlist Management Modal -->    <div id="playlist-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-40">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg space-y-4">
            <h2 class="text-2xl font-bold">Manage Playlists</h2>
            <div id="playlist-manager-list" class="space-y-2 max-h-64 overflow-y-auto"></div>
            
            <!-- Playlist Type Toggle -->
            <div class="space-y-4 border-t border-gray-600 pt-4">
                <div class="flex items-center space-x-4">
                    <label class="text-sm font-medium">Playlist Type:</label>
                    <div class="flex rounded-lg overflow-hidden">
                        <button id="m3u-mode-btn" class="px-4 py-2 bg-blue-600 text-white text-sm font-medium transition-colors">M3U URL</button>
                        <button id="xtreme-mode-btn" class="px-4 py-2 bg-gray-600 text-white text-sm font-medium transition-colors">Xtreme Codes</button>
                    </div>
                </div>
                
                <!-- M3U Mode Fields -->
                <div id="m3u-fields" class="space-y-2">
                    <input type="text" id="new-playlist-name" placeholder="Playlist Name" class="w-full bg-gray-700 rounded p-2">
                    <input type="url" id="new-playlist-url" placeholder="Playlist M3U URL" class="w-full bg-gray-700 rounded p-2">
                </div>
                
                <!-- Xtreme Codes Mode Fields -->
                <div id="xtreme-fields" class="space-y-2 hidden">
                    <input type="text" id="xtreme-playlist-name" placeholder="Playlist Name" class="w-full bg-gray-700 rounded p-2">
                    <input type="url" id="xtreme-portal-url" placeholder="Portal URL (e.g., http://example.com:8080)" class="w-full bg-gray-700 rounded p-2">
                    <input type="text" id="xtreme-username" placeholder="Username" class="w-full bg-gray-700 rounded p-2">
                    <input type="password" id="xtreme-password" placeholder="Password" class="w-full bg-gray-700 rounded p-2">
                    <div class="text-xs text-gray-400 mt-1">
                        Enter your Xtreme Codes panel credentials. The system will automatically generate the M3U URL.
                    </div>
                </div>
                
                <button id="add-playlist-btn" class="w-full bg-green-600 hover:bg-green-700 p-2 rounded">Add Playlist</button>
            </div>
            <button id="close-modal-btn" class="mt-4 w-full bg-gray-600 hover:bg-gray-700 p-2 rounded">Close</button>        </div>
    </div>
    
    <script>    document.addEventListener('DOMContentLoaded', () => {        // --- SECURITY CONTEXT DETECTION ---
        const isHttpsPage = window.location.protocol === 'https:';
        const isDevelopmentLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        
        // Store security context globally for use throughout the app
        window.securityContext = {
            isHttps: isHttpsPage,
            isDevelopment: isDevelopmentLocal,
            mixedContentBlocked: false, // Always false - allow all HTTP streams
            cspEnabled: false,
            allowAllMethods: true, // Force allow all playback methods
            forceHttpAccess: true, // New flag to force HTTP stream access
            bypassAllSecurity: true // Bypass all browser security restrictions
        };
        
        // Check for Content Security Policy
        const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
        if (cspMeta) {
            window.securityContext.cspEnabled = true;
            console.log('🛡️ CSP detected - will attempt bypass methods:', cspMeta.content);
        }
        
        // Listen for CSP violations but don't let them stop us
        document.addEventListener('securitypolicyviolation', function(e) {
            console.warn('🚫 CSP Violation detected - will use proxy methods:', {
                blockedURI: e.blockedURI,
                violatedDirective: e.violatedDirective,
                originalPolicy: e.originalPolicy
            });
        });
        
        // Always log permissive approach
        console.log('🌐 HTTP Stream Access: Enabled - All streams will be attempted via multiple methods');
        if (window.securityContext.isHttps) {
            console.log('� HTTPS to HTTP Bridge: Active - Using proxy and fallback methods for mixed content');
        }
        
        console.log('🔍 Security Context:', window.securityContext);
        
        // --- CONSTANTS ---
        // Enhanced proxy list with development fallbacks
        const PROXIES = [
            // High-reliability public proxies (2025)
            'https://cors.eu.org/',
            'https://thingproxy.freeboard.io/fetch/',
            'https://cors.bridged.cc/',
            'https://api.cors.lol/?url=',
            // Backup public proxies
            'https://api.allorigins.win/raw?url=',
            'https://cors-proxy.fringe.zone/',
            'https://proxy-cors.isomorphic-git.org/',
            // Alternative method proxies
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://yacdn.org/proxy/'
        ];
        
        // --- DOM ELEMENTS ---
        const videoPlayer = document.getElementById('video-player');
        const currentChannelDisplay = document.getElementById('current-channel');
        const channelNameDisplay = document.getElementById('channel-name');
        const statusIndicator = document.getElementById('status-indicator');
        const loadBtn = document.getElementById('load-btn');
        const channelList = document.getElementById('channel-list');
        const searchInput = document.getElementById('search-input');
        const groupFilter = document.getElementById('group-filter');
        const qualitySelect = document.getElementById('quality-select');
        const epgUrlInput = document.getElementById('epg-url');
        const errorMessage = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        const successMessage = document.getElementById('success-message');
        const successText = document.getElementById('success-text');
        const closeErrorBtn = document.getElementById('close-error');
        const closeSuccessBtn = document.getElementById('close-success');
        const loaderOverlay = document.getElementById('loader-overlay');
        const loadingTitle = document.getElementById('loading-title');
        const loadingProgress = document.getElementById('loading-progress');
        const loadingDetails = document.getElementById('loading-details');
        const loadingStats = document.getElementById('loading-stats');
        const progressBarContainer = document.getElementById('progress-bar-container');
        const progressBar = document.getElementById('progress-bar');
        const pipBtn = document.getElementById('pip-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const managePlaylistsBtn = document.getElementById('manage-playlists-btn');
        const playlistModal = document.getElementById('playlist-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const playlistSelect = document.getElementById('playlist-select');
        const playlistManagerList = document.getElementById('playlist-manager-list');
        const addPlaylistBtn = document.getElementById('add-playlist-btn');
        const newPlaylistNameInput = document.getElementById('new-playlist-name');
        const newPlaylistUrlInput = document.getElementById('new-playlist-url');
        
        // Xtreme Codes elements
        const m3uModeBtn = document.getElementById('m3u-mode-btn');
        const xtremeModeBtn = document.getElementById('xtreme-mode-btn');
        const m3uFields = document.getElementById('m3u-fields');
        const xtremeFields = document.getElementById('xtreme-fields');
        const xtremePlaylistNameInput = document.getElementById('xtreme-playlist-name');
        const xtremePortalUrlInput = document.getElementById('xtreme-portal-url');
        const xtremeUsernameInput = document.getElementById('xtreme-username');
        const xtremePasswordInput = document.getElementById('xtreme-password');
        
        // Debug panel elements
        const debugPanel = document.getElementById('debug-panel');
        const debugToggleBtn = document.getElementById('debug-toggle');
        const closeDebugBtn = document.getElementById('close-debug');
        const debugUrl = document.getElementById('debug-url');
        const debugMethod = document.getElementById('debug-method');
        const debugStatus = document.getElementById('debug-status');
        const debugSupport = document.getElementById('debug-support');
        const debugAttempts = document.getElementById('debug-attempts');
        const debugError = document.getElementById('debug-error');
        const debugCopyBtn = document.getElementById('debug-copy');
        const debugTestBtn = document.getElementById('debug-test');
        
        // --- STATE MANAGEMENT ---
        function loadStateFromStorage() {
            try {
                const saved = localStorage.getItem('iptvPlayerState');
                if (saved) {
                    const savedState = JSON.parse(saved);
                    appState = { ...appState, ...savedState };
                    console.log('🔄 Loaded state from storage');
                }
            } catch (error) {
                console.error('Error loading state from storage:', error);
            }
        }

        function saveStateToStorage() {
            try {
                localStorage.setItem('iptvPlayerState', JSON.stringify(appState));
            } catch (error) {
                console.error('Error saving state to storage:', error);
            }
        }

        // Save state when app state changes
        function updateAppState(updates) {
            appState = { ...appState, ...updates };
            saveStateToStorage();
        }

        let hls = null;
        let currentChannelIndex = -1;
        let displayedChannels = [];
        let appState = {
            allChannels: [], epgData: {}, favorites: [], recents: [],
            playlists: [], activePlaylistUrl: '', volume: 0.8, currentQuality: 'auto'
        };
        
        // --- IMAGE LOADING HELPER ---
        // Smart image URL generator that avoids double-encoding issues
        function getSmartImageUrls(imageUrl) {
            if (!imageUrl) {
                return {
                    primary: 'https://placehold.co/40x40/374151/ffffff?text=?',
                    fallback: 'https://placehold.co/40x40/374151/ffffff?text=?',
                    placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
                };
            }

            const isHttps = imageUrl.startsWith('https://');
            const isHttp = imageUrl.startsWith('http://');
            
            // For HTTPS images, try direct first (no CORS issues)
            if (isHttps) {
                return {
                    primary: imageUrl,
                    fallback: `${PROXIES[0]}${imageUrl}`, // Try proxied version as fallback
                    placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
                };
            }
            
            // For HTTP images, try proxied first (CORS + mixed content protection)
            if (isHttp) {
                return {
                    primary: `${PROXIES[0]}${imageUrl}`, // Non-encoded proxy
                    fallback: `${PROXIES[1]}${encodeURIComponent(imageUrl)}`, // Try different proxy with encoding
                    placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
                };
            }
            
            // For relative or other URLs, try to make them work
            return {
                primary: `${PROXIES[0]}${imageUrl}`,
                fallback: `${PROXIES[0]}${encodeURIComponent(imageUrl)}`,
                placeholder: 'https://placehold.co/40x40/374151/ffffff?text=?'
            };
        }

        // --- CORE FUNCTIONS ---
          // Tries to fetch a URL directly first, then using a list of proxies as fallback.
        // url: The original URL to fetch
        // proxyIndex: The current proxy to try from the PROXIES array (-1 means try direct first)
        // Returns: A promise that resolves with the fetch response
        async function fetchWithProxyFallback(url, proxyIndex = -1) {
            // First try direct fetch with enhanced headers for Vercel/cloud environments
            if (proxyIndex === -1) {
                console.log(`Trying direct fetch: ${url}`);
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout for direct
                      const response = await fetch(url, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-store',
                        credentials: 'omit',
                        signal: controller.signal,
                        headers: {
                            'Accept': '*/*'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        console.log('Direct fetch successful');
                        return response;
                    }
                    console.warn(`Direct fetch failed with status: ${response.status}, trying proxies...`);
                } catch (error) {
                    console.warn('Direct fetch failed, trying proxies...', error.name || error.message);
                }
                // If direct fails, start with proxy 0
                return fetchWithProxyFallback(url, 0);
            }

            // Proxy fallback logic with enhanced error handling for Vercel
            if (proxyIndex >= PROXIES.length) {
                throw new Error(`All ${PROXIES.length} proxies failed. This stream may be incompatible with cloud deployment or require special access.

🔧 VERCEL-SPECIFIC TROUBLESHOOTING:
• Some streams are blocked in cloud environments
• Try using a VPN or different network
• Check if stream works in VLC player
• Contact stream provider for web-compatible URLs

Technical details: Network restrictions, CORS policies, or geographic blocking may prevent playback on Vercel's edge network.`);
            }
            
            const proxy = PROXIES[proxyIndex];
            const fetchUrl = proxy + (proxy.includes('?') ? encodeURIComponent(url) : url);
            
            console.log(`Trying to fetch via proxy #${proxyIndex + 1}: ${proxy.replace(/^https?:\/\//, '').split('/')[0]}`);
            
            // Update loading screen with proxy attempt info
            if (loadingDetails && proxyIndex > 0) {
                updateLoadingScreen(
                    loadingTitle.textContent,
                    loadingProgress.textContent,
                    `Trying server ${proxyIndex + 1}/${PROXIES.length}...`,
                    `Previous server failed, retrying with different proxy`,
                    !progressBarContainer.classList.contains('hidden'),
                    progressBar.style.width ? parseInt(progressBar.style.width) : 0
                );
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20s timeout for proxies
                  const response = await fetch(fetchUrl, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-store',
                    credentials: 'omit',
                    signal: controller.signal,
                    headers: {
                        'Accept': '*/*'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    console.warn(`Proxy ${proxy.replace(/^https?:\/\//, '').split('/')[0]} failed with status: ${response.status}`);
                    // Wait before trying next proxy to avoid overwhelming servers
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return fetchWithProxyFallback(url, proxyIndex + 1);
                }
                
                console.log(`Successfully fetched via proxy: ${proxy.replace(/^https?:\/\//, '').split('/')[0]}`);
                return response;
            } catch (error) {
                const errorMsg = error.name === 'AbortError' ? 'timeout' : error.message;
                console.warn(`Proxy ${proxy.replace(/^https?:\/\//, '').split('/')[0]} failed: ${errorMsg}`);
                
                // Add progressive delay between proxy attempts
                const delay = Math.min(500 + (proxyIndex * 200), 2000);
                await new Promise(resolve => setTimeout(resolve, delay));
                
                return fetchWithProxyFallback(url, proxyIndex + 1);
            }
        }
        
        /**
         * Analyzes a stream URL to provide insights about HTTPS compatibility
         * @param {string} url - The stream URL to analyze
         * @returns {object} - Analysis results
         */
        function analyzeStreamCompatibility(url) {
            const analysis = {
                isHttp: url.startsWith('http://'),
                isHttps: url.startsWith('https://'),
                likelyHttpsIncompatible: false,
                reason: '',
                suggestions: []
            };
            
            if (analysis.isHttp) {
                // Check for common IPTV/streaming patterns that are typically HTTP-only
                const httpOnlyPatterns = [
                    /:\d{4,5}\//,  // Non-Standard ports (e.g., :8080/, :1935/)
                    /\/live\//,    // Live streaming endpoints
                    /\/stream\//,  // Stream endpoints
                    /\.ts$/,       // Transport stream files
                    /playlist\.m3u8/, // HLS playlists
                    /chunklist/,   // HLS chunks
                    /udp:\/\//,    // UDP streams
                    /rtmp:\/\//,   // RTMP streams
                ];
                
                analysis.likelyHttpsIncompatible = httpOnlyPatterns.some(pattern => pattern.test(url));
                
                if (analysis.likelyHttpsIncompatible) {
                    analysis.reason = 'URL contains patterns typical of HTTP-only streaming infrastructure';
                    analysis.suggestions = [
                        'Use proxy methods to bypass mixed content restrictions',
                        'Streaming servers often use HTTP due to SSL certificate costs',
                        'Consider asking provider about HTTPS support'
                    ];
                } else {
                    analysis.reason = 'HTTP URL that might support HTTPS upgrade';
                    analysis.suggestions = [
                        'Try HTTPS upgrade first',
                        'Fallback to proxy methods if HTTPS fails'
                    ];
                }
            }
            
            return analysis;
        }

        function init() {
            loadStateFromStorage();
            renderPlaylistSelect();
            renderPlaylistManagerList();
            videoPlayer.volume = appState.volume;
            qualitySelect.value = appState.currentQuality;
            setupKeyboardShortcuts();
            setupMediaSession();
            setupVideoEventListeners();
            if (appState.activePlaylistUrl) {
                const playlist = appState.playlists.find(p => p.url === appState.activePlaylistUrl);
                if (playlist) {
                    playlistSelect.value = playlist.url;
                    epgUrlInput.value = playlist.epgUrl || '';
                    loadPlaylist();
                }
            }
        }

        function setupVideoEventListeners() {
            videoPlayer.addEventListener('loadstart', () => {
                console.log('Video load started');
            });

            videoPlayer.addEventListener('loadedmetadata', () => {
                console.log('Video metadata loaded');
            });

            videoPlayer.addEventListener('canplay', () => {
                console.log('Video can start playing');
            });

            videoPlayer.addEventListener('playing', () => {
                console.log('Video is playing');
                hideError(); // Hide any previous errors when video starts playing
            });
            
            videoPlayer.addEventListener('error', (e) => {
                const error = videoPlayer.error;
                console.error('Video element error:', error);
                
                let errorMessage = 'Unknown playback error';
                let technicalDetails = '';
                let shouldAttemptRecovery = false;
                
                if (error) {
                    switch(error.code) {
                        case MediaError.MEDIA_ERR_ABORTED:
                            errorMessage = 'Video playback was aborted';
                            technicalDetails = 'The video download was cancelled';
                            break;
                        case MediaError.MEDIA_ERR_NETWORK:
                            errorMessage = 'Network error occurred while loading video';
                            technicalDetails = 'Check your internet connection and stream URL';
                            shouldAttemptRecovery = true;
                            break;
                        case MediaError.MEDIA_ERR_DECODE:
                            errorMessage = 'Video format error detected';
                            technicalDetails = 'Media decode error - attempting recovery';
                            shouldAttemptRecovery = true;
                            
                            // Attempt HLS.js media recovery if available
                            if (window.hls && typeof window.hls.recoverMediaError === 'function') {
                                console.log('Attempting HLS.js media error recovery...');
                                try {
                                    window.hls.recoverMediaError();
                                    showError('Attempting to recover from playback error...');
                                    return; // Don't show final error yet, let recovery attempt complete
                                } catch (recoveryError) {
                                    console.error('HLS.js recovery failed:', recoveryError);
                                }
                            }
                            break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMessage = 'Video source not supported';
                            technicalDetails = 'The video format or URL is not valid';
                            shouldAttemptRecovery = true;
                            break;
                        default:
                            errorMessage = `Media error (code: ${error.code})`;
                            technicalDetails = error.message || 'Unknown media error';
                            shouldAttemptRecovery = error.code !== MediaError.MEDIA_ERR_ABORTED;
                    }
                }
                
                // Log technical details for debugging
                console.log(`Technical details: ${technicalDetails}`);
                debugState.lastError = `${errorMessage} (${technicalDetails})`;
                updateDebugInfo();
                
                // Show user-friendly error message
                showError(errorMessage);
                updateStatus('error', 'Playback error');
                
                // Attempt recovery for recoverable errors
                if (shouldAttemptRecovery && currentChannelIndex >= 0) {
                    console.log('Attempting automatic error recovery...');
                    setTimeout(() => {
                        if (currentChannelIndex >= 0 && currentChannelIndex < displayedChannels.length) {
                            const channel = displayedChannels[currentChannelIndex];
                            console.log(`Retrying playback for channel: ${channel.name}`);
                            playChannel(channel.url, channel.name, channel.id);
                        }
                    }, 2000); // Wait 2 seconds before retry
                }
            });

            videoPlayer.addEventListener('stalled', () => {
                console.log('Video playback stalled');
                updateStatus('loading', 'Buffering...');
            });

            videoPlayer.addEventListener('waiting', () => {
                console.log('Video waiting for data');
                updateStatus('loading', 'Buffering...');
            });            videoPlayer.addEventListener('timeupdate', () => {
                // Update status back to playing if we were buffering
                if (statusIndicator.classList.contains('status-loading') && !videoPlayer.paused) {
                    const currentChannelName = channelNameDisplay.textContent.replace('Now Playing: ', '');
                    updateStatus('online', `Playing: ${currentChannelName}`);
                }
            });

            // Save volume changes
            videoPlayer.addEventListener('volumechange', () => {
                updateAppState({ volume: videoPlayer.volume });
            });
        }

        async function loadPlaylist() {
            const playlistUrl = playlistSelect.value;
            const epgUrl = epgUrlInput.value.trim();
            if (!playlistUrl) {
                showError("Please select a playlist.");
                return;
            }

            showLoadingScreen();
            hideError();
            hideSuccess();
            resetContent();
            updateStatus('loading', 'Loading playlist...');

            try {
                // Step 1: Fetch M3U playlist
                updateLoadingScreen(
                    'Fetching Playlist...',
                    'Step 1 of 3',
                    'Downloading M3U playlist file from server',
                    'This may take a few seconds depending on server response time',
                    true,
                    10
                );

                const startTime = Date.now();
                const m3uResponse = await fetchWithProxyFallback(playlistUrl);
                const fetchTime = ((Date.now() - startTime) / 1000).toFixed(1);
                
                updateLoadingScreen(
                    'Processing Playlist...',
                    'Step 2 of 3',
                    'Parsing M3U data and extracting channel information',
                    `Downloaded in ${fetchTime}s - Processing channels...`,
                    true,
                    40
                );

                const playlistData = await m3uResponse.text();
                const parseStartTime = Date.now();
                appState.allChannels = parseM3U(playlistData, playlistUrl);
                const parseTime = ((Date.now() - parseStartTime) / 1000).toFixed(1);

                if (appState.allChannels.length === 0) {
                    throw new Error("No valid channels found in the playlist");
                }

                updateLoadingScreen(
                    'Channels Loaded!',
                    'Step 2 Complete',
                    `Found ${appState.allChannels.length} channels in playlist`,
                    `Parsed ${appState.allChannels.length} channels in ${parseTime}s`,
                    true,
                    70
                );

                // Step 3: Load EPG if provided
                if (epgUrl) {
                    updateLoadingScreen(
                        'Loading EPG Data...',
                        'Step 3 of 3',
                        'Downloading Electronic Program Guide (TV schedules)',
                        'This provides show information and schedules for channels',
                        true,
                        75
                    );

                    try {
                        const epgStartTime = Date.now();
                        const epgResponse = await fetchWithProxyFallback(epgUrl);
                        const epgDataText = await epgResponse.text();
                        
                        updateLoadingScreen(
                            'Processing EPG...',
                            'Step 3 of 3',
                            'Parsing TV schedule data and matching with channels',
                            'Processing program information...',
                            true,
                            90
                        );
                        
                        appState.epgData = parseEPG(epgDataText);
                        const epgTime = ((Date.now() - epgStartTime) / 1000).toFixed(1);
                        const epgChannelCount = Object.keys(appState.epgData).length;
                        
                        updateLoadingScreen(
                            'Complete!',
                            'All Steps Done',
                            `Successfully loaded ${appState.allChannels.length} channels with EPG data`,
                            `EPG loaded in ${epgTime}s for ${epgChannelCount} channels`,
                            true,
                            100
                        );
                        
                        showSuccess(`Loaded ${appState.allChannels.length} channels with EPG data for ${epgChannelCount} channels`);
                    } catch(e) {
                         console.warn(`Could not load EPG: ${e.message}`);
                         updateLoadingScreen(
                            'Partial Success',
                            'EPG Failed',
                            `Loaded ${appState.allChannels.length} channels (EPG data unavailable)`,
                            `EPG failed: ${e.message}`,
                            true,
                            100
                        );
                         showSuccess(`Loaded ${appState.allChannels.length} channels (EPG failed to load)`);
                    }
                } else {
                    updateLoadingScreen(
                        'Complete!',
                        'All Steps Done',
                        `Successfully loaded ${appState.allChannels.length} channels`,
                        'No EPG URL provided - skipping program guide',
                        true,
                        100
                    );
                    showSuccess(`Loaded ${appState.allChannels.length} channels`);
                }
                
                const currentPlaylist = appState.playlists.find(p => p.url === playlistUrl);
                if (currentPlaylist) { currentPlaylist.epgUrl = epgUrl; }
                appState.activePlaylistUrl = playlistUrl;
                saveStateToStorage();
                
                // Final update before closing
                setTimeout(() => {
                    populateGroupFilter();
                    filterAndDisplayChannels();
                    updateStatus('online', 'Playlist loaded successfully');
                    hideLoadingScreen();
                }, 800); // Give user time to see completion message
                
            } catch (error) {
                console.error('Error loading playlist:', error);
                updateLoadingScreen(
                    'Error!',
                    'Loading Failed',
                    `Failed to load playlist: ${error.message}`,
                    'Please check your internet connection and playlist URL',
                    false,
                    0
                );
                
                setTimeout(() => {
                    hideLoadingScreen();
                    showError(`Failed to load playlist: ${error.message}`);
                    updateStatus('error', 'Failed to load playlist');
                }, 2000);
            }
        }
          function filterAndDisplayChannels() {
            const selectedGroup = groupFilter.value;
            const searchQuery = searchInput.value.toLowerCase();
            let channelsToDisplay = appState.allChannels;

            if (selectedGroup === 'favorites') {
                channelsToDisplay = appState.allChannels.filter(c => appState.favorites.includes(c.id));
            } else if (selectedGroup === 'recents') {
                 channelsToDisplay = appState.recents.map(id => appState.allChannels.find(c => c.id === id)).filter(Boolean);
            } else if (selectedGroup !== 'all') {
                channelsToDisplay = appState.allChannels.filter(c => c.group === selectedGroup);
            }
            if (searchQuery) {
                channelsToDisplay = channelsToDisplay.filter(c => c.name.toLowerCase().includes(searchQuery));
            }
            displayedChannels = channelsToDisplay;
            displayChannels(channelsToDisplay);
        }

        function displayChannels(channels) {
            channelList.innerHTML = '';
            if (channels.length === 0) {
                channelList.innerHTML = '<p class="text-gray-400 col-span-full text-center">No channels found.</p>';
                return;
            }
            channels.forEach(channel => {
                const isFavorite = appState.favorites.includes(channel.id);
                const { now, next } = getEpgForChannel(channel.id);
                const channelCard = document.createElement('div');
                channelCard.className = 'channel-item bg-gray-700 rounded-lg p-3 flex flex-col justify-between cursor-pointer transition hover:bg-gray-600';                // Smart logo loading: try direct first, then proxied versions
                const logoUrl = channel.logo || 'https://placehold.co/40x40/374151/ffffff?text=?';
                const isHttpsLogo = logoUrl.startsWith('https://');
                const primaryLogo = isHttpsLogo ? logoUrl : `${PROXIES[0]}${logoUrl}`;
                const fallbackLogo = isHttpsLogo ? `${PROXIES[0]}${logoUrl}` : `${PROXIES[0]}${encodeURIComponent(logoUrl)}`;

                channelCard.innerHTML = `
                    <div class="flex items-start space-x-3">
                        <img src="${primaryLogo}" 
                             onerror="this.onerror=null;this.src='${fallbackLogo}';this.onerror=function(){this.onerror=null;this.src='https://placehold.co/40x40/374151/ffffff?text=?';};" 
                             alt="logo" class="w-10 h-10 rounded-full object-cover bg-gray-600 flex-shrink-0">
                        <span class="font-semibold flex-grow">${channel.name}</span>
                        <span class="favorite-star text-2xl ${isFavorite ? 'favorited' : 'text-gray-500'}" data-channel-id="${channel.id}">&#9733;</span>
                    </div>
                    <div class="text-xs text-gray-300 mt-2 pl-13">
                        <p class="truncate" title="${now || 'No EPG data'}"><strong>Now:</strong> ${now || '...'}</p>
                        <p class="truncate" title="${next || 'No EPG data'}"><strong>Next:</strong> ${next || '...'}</p>
                    </div>`;
                
                channelCard.addEventListener('click', (e) => {
                    if (e.target.classList.contains('favorite-star')) {
                        toggleFavorite(channel.id);
                        e.stopPropagation();
                    } else {
                        const channelIndex = displayedChannels.findIndex(c => c.id === channel.id);
                        currentChannelIndex = channelIndex;
                        playChannel(channel.url, channel.name, channel.id);
                        document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
                        channelCard.classList.add('active');
                    }
                });
                channelList.appendChild(channelCard);
            });
        }
        
        // --- PLAYLIST UI RENDERING ---
        function renderPlaylistSelect() {
            // Clear existing options
            playlistSelect.innerHTML = '<option value="">Select a playlist...</option>';
            
            // Add all stored playlists
            appState.playlists.forEach(playlist => {
                const option = document.createElement('option');
                option.value = playlist.url;
                option.textContent = playlist.name;
                playlistSelect.appendChild(option);
            });
            
            console.log(`Rendered ${appState.playlists.length} playlists in dropdown`);
        }

        function renderPlaylistManagerList() {
            const playlistList = document.getElementById('playlist-list');
            if (!playlistList) return;
            
            // Clear existing list
            playlistList.innerHTML = '';
            
            if (appState.playlists.length === 0) {
                playlistList.innerHTML = '<p class="text-gray-400 text-center py-4">No playlists added yet</p>';
                return;
            }
            
            // Render each playlist
            appState.playlists.forEach((playlist, index) => {
                const playlistItem = document.createElement('div');
                playlistItem.className = 'bg-gray-700 rounded p-3 flex justify-between items-center';
                
                playlistItem.innerHTML = `
                    <div>
                        <div class="font-medium">${playlist.name}</div>
                        <div class="text-sm text-gray-400">${playlist.url}</div>
                    </div>
                    <button class="delete-playlist-btn bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm" data-index="${index}">
                        Delete
                    </button>
                `;
                
                playlistList.appendChild(playlistItem);
            });
            
            // Add event listeners for delete buttons
            document.querySelectorAll('.delete-playlist-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    deletePlaylist(index);
                });
            });
            
            console.log(`Rendered ${appState.playlists.length} playlists in manager`);
        }

        function deletePlaylist(index) {
            if (index >= 0 && index < appState.playlists.length) {
                const deletedPlaylist = appState.playlists[index];
                appState.playlists.splice(index, 1);
                
                // Clear active playlist if it was deleted
                if (appState.activePlaylistUrl === deletedPlaylist.url) {
                    appState.activePlaylistUrl = '';
                    playlistSelect.value = '';
                }
                
                updateAppState({ playlists: appState.playlists, activePlaylistUrl: appState.activePlaylistUrl });
                renderPlaylistSelect();
                renderPlaylistManagerList();
                
                console.log(`Deleted playlist: ${deletedPlaylist.name}`);
            }
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Only handle shortcuts if not typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    // Handle Ctrl+F for search even in input fields
                    if (e.ctrlKey && e.key === 'f') {
                        e.preventDefault();
                        searchInput.focus();
                        searchInput.select();
                    }
                    return;
                }
                
                switch(e.key) {
                    case 'f':
                    case 'F':
                        if (!e.ctrlKey) {
                            toggleFullscreen();
                        }
                        break;
                    case 'p':
                    case 'P':
                        togglePictureInPicture();
                        break;
                    case ' ':
                        e.preventDefault();
                        if (videoPlayer.paused) {
                            videoPlayer.play();
                        } else {
                            videoPlayer.pause();
                        }
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        videoPlayer.volume = Math.min(1, videoPlayer.volume + 0.1);
                        updateAppState({ volume: videoPlayer.volume });
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        videoPlayer.volume = Math.max(0, videoPlayer.volume - 0.1);
                        updateAppState({ volume: videoPlayer.volume });
                        break;
                }
                
                // Handle Ctrl+F for search
                if (e.ctrlKey && e.key === 'f') {
                    e.preventDefault();
                    searchInput.focus();
                    searchInput.select();
                }
            });
            
            console.log('Keyboard shortcuts initialized');
        }

        function setupMediaSession() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => {
                    videoPlayer.play();
                });
                
                navigator.mediaSession.setActionHandler('pause', () => {
                    videoPlayer.pause();
                });
                
                navigator.mediaSession.setActionHandler('stop', () => {
                    videoPlayer.pause();
                    videoPlayer.currentTime = 0;
                });
                
                console.log('Media session handlers set up');
            }
        }

        function updateMediaSessionMetadata(channelName, logoUrl) {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: channelName,
                    artist: 'IPTV Player',
                    album: 'Live Stream',
                    artwork: logoUrl ? [
                        { src: logoUrl, sizes: '96x96', type: 'image/png' },
                        { src: logoUrl, sizes: '128x128', type: 'image/png' },
                        { src: logoUrl, sizes: '192x192', type: 'image/png' },
                        { src: logoUrl, sizes: '256x256', type: 'image/png' }
                    ] : []
                });
            }
        }

        /**
         * Validates a stream URL and ensures it uses HTTP/HTTPS protocol
         * @param {string} url - The URL to validate
         * @returns {string} - The validated and cleaned URL
         * @throws {Error} - If the URL is invalid or uses unsupported protocol
         */
        function validateUrl(url) {
            if (!url || typeof url !== 'string') {
                throw new Error('Invalid URL: URL must be a non-empty string');
            }
            
            // Remove any leading/trailing whitespace
            const cleanUrl = url.trim();
            
            if (!cleanUrl) {
                throw new Error('Invalid URL: URL cannot be empty');
            }
            
            try {
                const urlObj = new URL(cleanUrl);
                
                // Check if protocol is supported
                if (!['http:', 'https:'].includes(urlObj.protocol)) {
                    throw new Error(`Unsupported protocol: ${urlObj.protocol}. Only HTTP and HTTPS URLs are supported.`);
                }
                
                return cleanUrl;
            } catch (error) {
                if (error.message.includes('Unsupported protocol')) {
                    throw error;
                }
                throw new Error(`Invalid URL format: ${cleanUrl}. Please ensure the URL is properly formatted (e.g., http://example.com/stream.m3u8)`);
            }
        }        /**
         * Attempts to upgrade an HTTP URL to HTTPS and play the stream
         * @param {string} url - The original HTTP URL
         * @param {string} name - Channel name
         * @param {string} channelId - Channel ID
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */        async function tryHttpsUpgrade(url, name, channelId) {
            console.log('🔒 Attempting HTTPS upgrade for mixed content resolution...');
            
            // Only attempt if URL is HTTP
            if (!url.startsWith('http://')) {
                console.log('URL is not HTTP, skipping HTTPS upgrade');
                return false;
            }
            
            try {
                const httpsUrl = url.replace('http://', 'https://');
                console.log(`🔄 Upgrading URL: ${url} -> ${httpsUrl}`);
                
                updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Testing', 'Checking if HTTPS version exists');
                
                // Test if HTTPS version is accessible with reduced timeout and better error handling
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                
                try {
                    const response = await fetch(httpsUrl, {
                        method: 'HEAD',
                        mode: 'cors',
                        cache: 'no-store',
                        credentials: 'omit',
                        signal: controller.signal,
                        headers: {
                            'Accept': '*/*',
                            'User-Agent': 'Mozilla/5.0 (compatible; IPTV-Player)'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        console.log(`❌ HTTPS upgrade failed: HTTP ${response.status} ${response.statusText}`);
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', `Server returned ${response.status} - HTTPS not supported`);
                        return false;
                    }
                    
                    console.log('✅ HTTPS version is accessible, attempting playback...');
                    updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Success', 'HTTPS version accessible');
                    
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    
                    // Common HTTPS upgrade failure scenarios
                    if (fetchError.name === 'AbortError') {
                        console.log('❌ HTTPS upgrade timeout - server likely doesn\'t support HTTPS');
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'Timeout - HTTPS not supported');
                    } else if (fetchError.message.includes('net::ERR_SSL') || fetchError.message.includes('SSL')) {
                        console.log('❌ HTTPS upgrade failed - SSL/TLS certificate issues');
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'SSL certificate error');
                    } else if (fetchError.message.includes('net::ERR_CONNECTION_REFUSED')) {
                        console.log('❌ HTTPS upgrade failed - server doesn\'t accept HTTPS connections');
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'HTTPS port not available');
                    } else {
                        console.log('❌ HTTPS upgrade failed - general network error:', fetchError.message);
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'Network error - HTTPS not available');
                    }
                    return false;
                }
                
                // Try both direct and HLS playback for HTTPS URL
                if (httpsUrl.includes('.m3u8') || httpsUrl.includes('playlist')) {
                    // Try HLS.js first for M3U8 streams
                    if (Hls.isSupported()) {
                        const hlsSuccess = await new Promise((resolve) => {
                            if (window.hls) {
                                window.hls.destroy();
                            }
                            
                            window.hls = new Hls({
                                enableWorker: true,
                                lowLatencyMode: true,
                                backBufferLength: 90,
                                xhrSetup: function(xhr, url) {
                                    // Minimal headers for HTTPS upgrade
                                    xhr.setRequestHeader('Accept', '*/*');
                                }
                            });
                            
                            const onManifestParsed = () => {
                                console.log('✅ HTTPS upgrade HLS manifest loaded successfully');
                                videoPlayer.play().then(() => {
                                    updateStatus('online', `Playing: ${name} (HTTPS)`);
                                    channelNameDisplay.textContent = `Now Playing: ${name}`;
                                    updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Success', 'HLS playback started');
                                    cleanup();
                                    resolve(true);
                                }).catch(err => {
                                    console.log('❌ HTTPS upgrade HLS playback failed:', err);
                                    cleanup();
                                    resolve(false);
                                });
                            };
                            
                            const onError = (event, data) => {
                                console.log('❌ HTTPS upgrade HLS error:', data);
                                updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', `HLS error: ${data.type}`);
                                cleanup();
                                resolve(false);
                            };
                            
                            const cleanup = () => {
                                window.hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                window.hls.off(Hls.Events.ERROR, onError);
                            };
                            
                            window.hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                            window.hls.on(Hls.Events.ERROR, onError);
                            window.hls.loadSource(httpsUrl);
                            window.hls.attachMedia(videoPlayer);
                            
                            // Timeout after 15 seconds
                            setTimeout(() => {
                                cleanup();
                                if (window.hls) {
                                    window.hls.destroy();
                                    window.hls = null;
                                }
                                resolve(false);
                            }, 15000);
                        });
                        
                        if (hlsSuccess) {
                            return true;
                        }
                    }
                }
                
                // Try direct playback with HTTPS URL
                return new Promise((resolve) => {
                    videoPlayer.src = httpsUrl;
                    
                    const onCanPlay = () => {
                        console.log('✅ HTTPS upgrade direct playback successful');
                        updateStatus('online', `Playing: ${name} (HTTPS)`);
                        channelNameDisplay.textContent = `Now Playing: ${name}`;
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Success', 'Direct playback started');
                        cleanup();
                        resolve(true);
                    };
                    
                    const onError = (error) => {
                        console.log('❌ HTTPS upgrade direct playback failed:', error);
                        updateDebugInfo(httpsUrl, 'HTTPS Upgrade', 'Failed', 'Direct playback error');
                        cleanup();
                        resolve(false);
                    };
                    
                    const cleanup = () => {
                        videoPlayer.removeEventListener('canplay', onCanPlay);
                        videoPlayer.removeEventListener('error', onError);
                    };
                    
                    videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
                    videoPlayer.addEventListener('error', onError, { once: true });
                    
                    // Timeout after 15 seconds
                    setTimeout(() => {
                        cleanup();
                        resolve(false);
                    }, 15000);
                });
                
            } catch (error) {
                console.log('❌ HTTPS upgrade failed:', error.message);
                updateDebugInfo(httpsUrl || url, 'HTTPS Upgrade', 'Failed', `Network error: ${error.message}`);
                return false;
            }        }

        /**
         * Attempts to play a stream through a server proxy
         * @param {string} url - The stream URL
         * @param {string} name - Channel name
         * @param {string} channelId - Channel ID
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */        async function tryServerProxy(url, name, channelId) {
            console.log('🔄 Attempting server proxy playback for HTTP stream on HTTPS page...');
            
            try {
                // Use our API proxy endpoint if available
                const proxyUrl = `/api/proxy?url=${encodeURIComponent(url)}`;
                
                updateDebugInfo(proxyUrl, 'Server Proxy', 'Testing', 'Using Vercel serverless proxy to bypass mixed content');
                
                // Test proxy availability first with a HEAD request
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                
                try {
                    const testResponse = await fetch(proxyUrl, {
                        method: 'HEAD',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!testResponse.ok) {
                        if (testResponse.status === 502 || testResponse.status === 503) {
                            console.log(`❌ Server proxy failed: Streaming server unreachable (${testResponse.status})`);
                            updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', 'Streaming server unreachable - common with HTTP-only IPTV servers');
                        } else {
                            console.log(`❌ Server proxy failed: HTTP ${testResponse.status}`);
                            updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', `Proxy error ${testResponse.status}`);
                        }
                        return false;
                    }
                    
                    console.log('✅ Server proxy accessible, attempting stream playback...');
                    updateDebugInfo(proxyUrl, 'Server Proxy', 'Success', 'Proxy responding, trying playback');
                    
                } catch (proxyError) {
                    clearTimeout(timeoutId);
                    
                    if (proxyError.name === 'AbortError') {
                        console.log('❌ Server proxy timeout - streaming server likely slow or unreachable');
                        updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', 'Timeout - streaming server too slow');
                    } else {
                        console.log('❌ Server proxy network error:', proxyError.message);
                        updateDebugInfo(proxyUrl, 'Server Proxy', 'Failed', 'Network error reaching streaming server');
                    }
                    return false;
                }
                
                // Check if it's an HLS stream
                if (url.includes('.m3u8') || url.includes('playlist')) {
                    // Use HLS.js for M3U8 streams through proxy
                    if (Hls.isSupported()) {
                        return new Promise((resolve) => {
                            if (window.hls) {
                                window.hls.destroy();
                            }
                            
                            window.hls = new Hls({
                                enableWorker: true,
                                lowLatencyMode: true,
                                backBufferLength: 90
                            });
                            
                            const onManifestParsed = () => {
                                console.log('Server proxy HLS manifest loaded successfully');
                                videoPlayer.play().then(() => {
                                    updateStatus('online', `Playing: ${name} (Server Proxy)`);
                                    channelNameDisplay.textContent = `Now Playing: ${name}`;
                                    cleanup();
                                    resolve(true);
                                }).catch((error) => {
                                    console.log('Server proxy HLS playback failed:', error);
                                    cleanup();
                                    resolve(false);
                                });
                            };
                            
                            const onError = (event, data) => {
                                console.log('Server proxy HLS error:', data);
                                cleanup();
                                resolve(false);
                            };
                            
                            const cleanup = () => {
                                window.hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                window.hls.off(Hls.Events.ERROR, onError);
                            };
                            
                            window.hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                            window.hls.on(Hls.Events.ERROR, onError);
                            window.hls.loadSource(proxyUrl);
                            window.hls.attachMedia(videoPlayer);
                            
                            // Timeout after 20 seconds
                            setTimeout(() => {
                                cleanup();
                                if (window.hls) {
                                    window.hls.destroy();
                                    window.hls = null;
                                }
                                resolve(false);
                            }, 20000);
                        });
                    }
                } else {
                    // Direct proxy playback for non-HLS streams
                    videoPlayer.src = proxyUrl;
                    
                    return new Promise((resolve) => {
                        const onCanPlay = () => {
                            console.log('Server proxy direct playback successful');
                            updateStatus('online', `Playing: ${name} (Server Proxy)`);
                            channelNameDisplay.textContent = `Now Playing: ${name}`;
                            cleanup();
                            resolve(true);
                        };
                        
                        const onError = (error) => {
                            console.log('Server proxy direct playback failed:', error);
                            cleanup();
                            resolve(false);
                        };
                        
                        const cleanup = () => {
                            videoPlayer.removeEventListener('canplay', onCanPlay);
                            videoPlayer.removeEventListener('error', onError);
                        };
                        
                        videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
                        videoPlayer.addEventListener('error', onError, { once: true });
                        
                        // Timeout after 15 seconds
                        setTimeout(() => {
                            cleanup();
                            resolve(false);
                        }, 15000);
                    });
                }
                
            } catch (error) {
                console.log('Server proxy failed:', error.message);
                updateDebugInfo('', '', 'Failed', `Server proxy error: ${error.message}`);
                return false;
            }
        }

        /**
         * Attempts to play a stream through a secure CORS proxy (HTTPS)
         * @param {string} url - The stream URL
         * @param {string} name - Channel name
         * @param {string} channelId - Channel ID
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */
        async function trySecureProxy(url, name, channelId) {
            console.log('Attempting secure proxy playback...');
            
            // Secure proxies for mixed content scenarios
            const secureProxies = [
                'https://cors-anywhere.herokuapp.com/',
                'https://thingproxy.freeboard.io/fetch/',
                'https://api.allorigins.win/raw?url='
            ];
            
            for (const proxy of secureProxies) {
                try {
                    console.log(`Trying secure proxy: ${proxy}`);
                    const proxyUrl = proxy + encodeURIComponent(url);
                    
                    updateDebugInfo(proxyUrl, 'Secure Proxy', `Testing ${proxy}`);
                    
                    // Test proxy availability first with a HEAD request
                    const testResponse = await fetch(proxyUrl, {
                        method: 'HEAD',
                        mode: 'cors',
                        cache: 'no-store',
                        credentials: 'omit',
                        signal: AbortSignal.timeout(8000)
                    });
                    
                    if (!testResponse.ok) {
                        console.log(`Secure proxy ${proxy} not available: HTTP ${testResponse.status}`);
                        continue;
                    }
                    
                    console.log(`Secure proxy ${proxy} is available, attempting playback...`);
                    
                    // Check if it's an HLS stream
                    if (url.includes('.m3u8') || url.includes('playlist')) {
                        // Use HLS.js for M3U8 streams through secure proxy
                        if (Hls.isSupported()) {
                            const success = await new Promise((resolve) => {
                                if (window.hls) {
                                    window.hls.destroy();
                                }
                                
                                window.hls = new Hls({
                                    enableWorker: true,
                                    lowLatencyMode: true,
                                    backBufferLength: 90,
                                    xhrSetup: function(xhr, url) {
                                        // Minimal headers for secure proxy
                                        xhr.setRequestHeader('Accept', '*/*');
                                    }
                                });
                                
                                const onManifestParsed = () => {
                                    console.log(`Secure proxy ${proxy} HLS manifest loaded`);
                                    videoPlayer.play().then(() => {
                                        updateStatus('online', `Playing: ${name} (Secure Proxy)`);
                                        channelNameDisplay.textContent = `Now Playing: ${name}`;
                                        cleanup();
                                        resolve(true);
                                    }).catch((error) => {
                                        console.log(`Secure proxy ${proxy} HLS playback failed:`, error);
                                        cleanup();
                                        resolve(false);
                                    });
                                };
                                
                                const onError = (event, data) => {
                                    console.log(`Secure proxy ${proxy} HLS error:`, data);
                                    cleanup();
                                    resolve(false);
                                };
                                
                                const cleanup = () => {
                                    window.hls.off(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                    window.hls.off(Hls.Events.ERROR, onError);
                                };
                                
                                window.hls.on(Hls.Events.MANIFEST_PARSED, onManifestParsed);
                                window.hls.on(Hls.Events.ERROR, onError);
                                window.hls.loadSource(proxyUrl);
                                window.hls.attachMedia(videoPlayer);
                                
                                // Timeout after 15 seconds
                                setTimeout(() => {
                                    cleanup();
                                    if (window.hls) {
                                        window.hls.destroy();
                                        window.hls = null;
                                    }
                                    resolve(false);
                                }, 15000);
                            });
                            
                            if (success) {
                                return true;
                            }
                        }
                    } else {
                        // Direct proxy playback for non-HLS streams
                        const success = await new Promise((resolve) => {
                            videoPlayer.src = proxyUrl;
                            
                            const onCanPlay = () => {
                                console.log(`Secure proxy ${proxy} direct playback successful`);
                                updateStatus('online', `Playing: ${name} (Secure Proxy)`);
                                channelNameDisplay.textContent = `Now Playing: ${name}`;
                                cleanup();
                                resolve(true);
                            };
                            
                            const onError = (error) => {
                                console.log(`Secure proxy ${proxy} direct playback failed:`, error);
                                cleanup();
                                resolve(false);
                            };
                            
                            const cleanup = () => {
                                videoPlayer.removeEventListener('canplay', onCanPlay);
                                videoPlayer.removeEventListener('error', onError);
                            };
                            
                            videoPlayer.addEventListener('canplay', onCanPlay, { once: true });
                            videoPlayer.addEventListener('error', onError, { once: true });
                              // Timeout after 10 seconds
                            setTimeout(() => {
                                cleanup();
                                resolve(false);
                            }, 10000);
                        });
                        
                        if (success) {
                            return true;
                        }
                    }
                } catch (error) {
                    console.log(`Secure proxy ${proxy} failed:`, error.message);
                    updateDebugInfo('', '', 'Failed', `Secure proxy ${proxy} error: ${error.message}`);
                    // Continue to next proxy
                }
            }            console.log('All secure proxies failed');
            return false;
        }

        // Initialize the application when DOM is ready
        init();
    });
    </script>
</body>
</html>